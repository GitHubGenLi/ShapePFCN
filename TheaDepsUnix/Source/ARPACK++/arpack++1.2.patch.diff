diff -rupN arpack++/include/arbgcomp.h /usr/local/include/arpack++/arbgcomp.h
--- arpack++/include/arbgcomp.h	2000-02-20 19:04:16.000000000 +0530
+++ /usr/local/include/arpack++/arbgcomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBGComp.h.
-   Arpack++ class ARluCompGenEig definition
+   Arpack++ class ARbdCompGenEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,7 +18,7 @@
 #ifndef ARBGCOMP_H
 #define ARBGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbnsmat.h"
 #include "arbnspen.h"
@@ -27,7 +27,7 @@
 
 
 template<class ARFLOAT>
-class ARluCompGenEig:
+class ARbdCompGenEig:
   public virtual
     ARCompGenEig<ARFLOAT, ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                  ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > > {
@@ -40,7 +40,7 @@ class ARluCompGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluCompGenEig& other);
+  virtual void Copy(const ARbdCompGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -60,68 +60,68 @@ class ARluCompGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluCompGenEig() { }
+  ARbdCompGenEig() { }
   // Short constructor.
 
-  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARbdCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 char* whichp = "LM", int ncvp = 0,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARbdCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }
+  ARbdCompGenEig(const ARbdCompGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompGenEig() { }
+  virtual ~ARbdCompGenEig() { }
 
  // d) Operators.
 
-  ARluCompGenEig& operator=(const ARluCompGenEig& other);
+  ARbdCompGenEig& operator=(const ARbdCompGenEig& other);
   // Assignment operator.
 
-}; // class ARluCompGenEig.
+}; // class ARbdCompGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompGenEig member functions definition.                              //
+// ARbdCompGenEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
-Copy(const ARluCompGenEig<ARFLOAT>& other)
+inline void ARbdCompGenEig<ARFLOAT>::
+Copy(const ARbdCompGenEig<ARFLOAT>& other)
 {
 
   ARCompGenEig<ARFLOAT, ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARbdCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()
+inline void ARbdCompGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
@@ -133,7 +133,7 @@ inline void ARluCompGenEig<ARFLOAT>::Set
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARbdCompGenEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
@@ -146,19 +146,19 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
+inline ARbdCompGenEig<ARFLOAT>::
+ARbdCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp,
                arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
-                   &Pencil, 
+                   &Pencil,
                    &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -166,20 +166,20 @@ ARluCompGenEig(int nevp, ARbdNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+inline ARbdCompGenEig<ARFLOAT>::
+ARbdCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
-                   &Pencil, 
-                   &ARbdNonSymPencil<arcomplex<ARFLOAT>,ARFLOAT>::MultBv, 
+                   &Pencil,
+                   &ARbdNonSymPencil<arcomplex<ARFLOAT>,ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
   SetShiftInvertMode(sigmap);
 
@@ -187,12 +187,12 @@ ARluCompGenEig(int nevp, ARbdNonSymMatri
 
 
 template<class ARFLOAT>
-ARluCompGenEig<ARFLOAT>& ARluCompGenEig<ARFLOAT>::
-operator=(const ARluCompGenEig<ARFLOAT>& other)
+ARbdCompGenEig<ARFLOAT>& ARbdCompGenEig<ARFLOAT>::
+operator=(const ARbdCompGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbgnsym.h /usr/local/include/arpack++/arbgnsym.h
--- arpack++/include/arbgnsym.h	2000-02-20 18:48:20.000000000 +0530
+++ /usr/local/include/arpack++/arbgnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBGNSym.h.
-   Arpack++ class ARluNonSymGenEig definition
+   Arpack++ class ARbdNonSymGenEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,7 +18,7 @@
 #ifndef ARBGNSYM_H
 #define ARBGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbnsmat.h"
 #include "arbnspen.h"
@@ -26,7 +26,7 @@
 
 
 template<class ARFLOAT>
-class ARluNonSymGenEig:
+class ARbdNonSymGenEig:
   public virtual ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
                                 ARbdNonSymPencil<ARFLOAT, ARFLOAT> > {
 
@@ -38,7 +38,7 @@ class ARluNonSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluNonSymGenEig& other);
+  virtual void Copy(const ARbdNonSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -60,73 +60,73 @@ class ARluNonSymGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluNonSymGenEig() { }
+  ARbdNonSymGenEig() { }
   // Short constructor.
 
-  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
+  ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
-                   char* whichp = "LM", int ncvp = 0,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (real shift and invert mode).
 
-  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
-                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
+                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
 
-  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }
+  ARbdNonSymGenEig(const ARbdNonSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymGenEig() { }
+  virtual ~ARbdNonSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluNonSymGenEig& operator=(const ARluNonSymGenEig& other);
+  ARbdNonSymGenEig& operator=(const ARbdNonSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymGenEig.
+}; // class ARbdNonSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymGenEig member functions definition.                            //
+// ARbdNonSymGenEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
-Copy(const ARluNonSymGenEig<ARFLOAT>& other)
+inline void ARbdNonSymGenEig<ARFLOAT>::
+Copy(const ARbdNonSymGenEig<ARFLOAT>& other)
 {
 
   ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARbdNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARbdNonSymGenEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -134,7 +134,7 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARbdNonSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT> >::
@@ -144,7 +144,7 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARbdNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
@@ -156,7 +156,7 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARbdNonSymGenEig<ARFLOAT>::
 SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
@@ -170,16 +170,16 @@ SetComplexShiftMode(char partp, ARFLOAT
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
+inline ARbdNonSymGenEig<ARFLOAT>::
+ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -188,16 +188,16 @@ ARluNonSymGenEig(int nevp, ARbdNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+inline ARbdNonSymGenEig<ARFLOAT>::
+ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                  ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -207,16 +207,16 @@ ARluNonSymGenEig(int nevp, ARbdNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp, 
-                 ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp, int ncvp, 
+inline ARbdNonSymGenEig<ARFLOAT>::
+ARbdNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
+                 ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -226,12 +226,12 @@ ARluNonSymGenEig(int nevp, ARbdNonSymMat
 
 
 template<class ARFLOAT>
-ARluNonSymGenEig<ARFLOAT>& ARluNonSymGenEig<ARFLOAT>::
-operator=(const ARluNonSymGenEig<ARFLOAT>& other)
+ARbdNonSymGenEig<ARFLOAT>& ARbdNonSymGenEig<ARFLOAT>::
+operator=(const ARbdNonSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbgsym.h /usr/local/include/arpack++/arbgsym.h
--- arpack++/include/arbgsym.h	2000-02-20 18:40:22.000000000 +0530
+++ /usr/local/include/arpack++/arbgsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBGSym.h.
-   Arpack++ class ARluSymGenEig definition
+   Arpack++ class ARbdSymGenEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,7 +18,7 @@
 #ifndef ARBGSYM_H
 #define ARBGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbsmat.h"
 #include "arbspen.h"
@@ -26,7 +26,7 @@
 
 
 template<class ARFLOAT>
-class ARluSymGenEig:
+class ARbdSymGenEig:
   public virtual ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>,
                              ARbdSymPencil<ARFLOAT> > {
 
@@ -38,7 +38,7 @@ class ARluSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluSymGenEig& other);
+  virtual void Copy(const ARbdSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -62,67 +62,67 @@ class ARluSymGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluSymGenEig() { }
+  ARbdSymGenEig() { }
   // Short constructor.
 
-  ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-                ARbdSymMatrix<ARFLOAT>& B, char* whichp = "LM",
+  ARbdSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+                ARbdSymMatrix<ARFLOAT>& B, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
-                ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
+  ARbdSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
+                ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert, buckling and Cayley modes).
 
-  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }
+  ARbdSymGenEig(const ARbdSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymGenEig() { }
+  virtual ~ARbdSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluSymGenEig& operator=(const ARluSymGenEig& other);
+  ARbdSymGenEig& operator=(const ARbdSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluSymGenEig.
+}; // class ARbdSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymGenEig member functions definition.                               //
+// ARbdSymGenEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
-Copy(const ARluSymGenEig<ARFLOAT>& other)
+inline void ARbdSymGenEig<ARFLOAT>::
+Copy(const ARbdSymGenEig<ARFLOAT>& other)
 {
 
   ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>,
               ARbdSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
+inline void ARbdSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARbdSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdSymPencil<ARFLOAT> >::
@@ -132,7 +132,7 @@ inline void ARluSymGenEig<ARFLOAT>::SetR
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARbdSymGenEig<ARFLOAT>::
 SetShiftInvertMode(ARFLOAT sigmap)
 {
 
@@ -144,7 +144,7 @@ SetShiftInvertMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARbdSymGenEig<ARFLOAT>::
 SetBucklingMode(ARFLOAT sigmap)
 {
 
@@ -156,7 +156,7 @@ SetBucklingMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARbdSymGenEig<ARFLOAT>::
 SetCayleyMode(ARFLOAT sigmap)
 {
 
@@ -169,17 +169,17 @@ SetCayleyMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-              ARbdSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
+inline ARbdSymGenEig<ARFLOAT>::
+ARbdSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+              ARbdSymMatrix<ARFLOAT>& B, const char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->InvertMode = 'S';
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -188,25 +188,25 @@ ARluSymGenEig(int nevp, ARbdSymMatrix<AR
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
+inline ARbdSymGenEig<ARFLOAT>::
+ARbdSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
               ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
-              char* whichp, int ncvp, ARFLOAT tolp,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':
     ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
   case 'S':
-    ChangeShift(sigmap);
+    this->ChangeShift(sigmap);
     break;
   case 'C':
     SetCayleyMode(sigmap);
@@ -216,12 +216,12 @@ ARluSymGenEig(char InvertModep, int nevp
 
 
 template<class ARFLOAT>
-ARluSymGenEig<ARFLOAT>& ARluSymGenEig<ARFLOAT>::
-operator=(const ARluSymGenEig<ARFLOAT>& other)
+ARbdSymGenEig<ARFLOAT>& ARbdSymGenEig<ARFLOAT>::
+operator=(const ARbdSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbnsmat.h /usr/local/include/arpack++/arbnsmat.h
--- arpack++/include/arbnsmat.h	2000-02-21 04:30:46.000000000 +0530
+++ /usr/local/include/arpack++/arbnsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,7 @@
 #ifndef ARBNSMAT_H
 #define ARBNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -46,7 +46,7 @@ class ARbdNonSymMatrix: public ARMatrix<
   ARTYPE*  A;
   ARTYPE*  Ainv;
 
-  void ClearMem(); 
+  void ClearMem();
 
   virtual void Copy(const ARbdNonSymMatrix& other);
 
@@ -57,7 +57,7 @@ class ARbdNonSymMatrix: public ARMatrix<
   void CreateStructure();
 
   void ThrowError();
-  
+
  public:
 
   bool IsFactored() { return factored; }
@@ -104,11 +104,11 @@ class ARbdNonSymMatrix: public ARMatrix<
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()
-{ 
+{
 
   if (factored) {
     delete[] Ainv;
-    delete[] ipiv; 
+    delete[] ipiv;
     Ainv = NULL;
     ipiv = NULL;
   }
@@ -123,9 +123,9 @@ Copy(const ARbdNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+   this->n         = other.n;
+   this->defined   = other.defined;
   factored  = other.factored;
   ndiagL    = other.ndiagL;
   ndiagU    = other.ndiagU;
@@ -139,11 +139,11 @@ Copy(const ARbdNonSymMatrix<ARTYPE, ARFL
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[n*lda];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[ this->n*lda];
+  ipiv = new int[ this->n];
 
-  copy(n*lda, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy( this->n*lda, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i< this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -153,12 +153,12 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 {
 
   int i, inca;
- 
+
   // Copying A to Ainv.
 
   inca = ndiagL+ndiagU+1;
   for (i = 0; i < inca; i++) {
-    copy(n, &A[i], inca, &Ainv[ndiagL+i], lda);
+    copy( this->n, &A[i], inca, &Ainv[ndiagL+i], lda);
   }
 
 } // ExpandA.
@@ -174,7 +174,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Subtracting sigma from diagonal elements.
 
-  for (int i=(ndiagL+ndiagU); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
+  for (int i=(ndiagL+ndiagU); i<(lda* this->n); i+=lda) Ainv[i] -= sigma;
 
 } // SubtractAsI.
 
@@ -184,8 +184,8 @@ inline void ARbdNonSymMatrix<ARTYPE, ARF
 {
 
   ClearMem();
-  Ainv = new ARTYPE[lda*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[lda* this->n];
+  ipiv = new int[ this->n];
 
 } // CreateStructure.
 
@@ -212,7 +212,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::FactorA");
   }
 
@@ -226,7 +226,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing A.
 
-  gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
+  gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -243,7 +243,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARbdNonSymMatrix::FactorAsI");
   }
@@ -258,7 +258,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing AsI.
 
-  gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
+  gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -281,13 +281,13 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  gbmv("N", m, n, ndiagL, ndiagU, one, A,
+  gbmv(APP_C_STR("N"),  this->m,  this->n, ndiagL, ndiagU, one, A,
        ndiagL+ndiagU+1, v, 1, zero, w, 1);
 
 } // MultMv.
@@ -297,22 +297,22 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE  one;   
-  ARTYPE  zero; 
+  ARTYPE  one;
+  ARTYPE  zero;
 
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  gbmv("T", m, n, ndiagL, ndiagU, one, A,
-       ndiagL+ndiagU+1, v, 1, zero, w, 1);   
+  gbmv("T",  this->m,  this->n, ndiagL, ndiagU, one, A,
+       ndiagL+ndiagU+1, v, 1, zero, w, 1);
 
 } // MultMtv.
 
@@ -321,7 +321,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[ this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -335,7 +335,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[ this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -349,8 +349,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[ this->m],w);
+  MultMtv(v,&w[ this->m]);
 
 } // Mult0MMt0v.
 
@@ -368,11 +368,11 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy( this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  gbtrs("N", n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w, m, info);
+  gbtrs(APP_C_STR("N"),  this->n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w,  this->m, info);
 
   // Handling errors.
 
@@ -388,28 +388,28 @@ DefineMatrix(int np, int ndiagLp, int nd
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+   this->m         = np;
+   this->n         = np;
   ndiagL    = ndiagLp;
   ndiagU    = ndiagUp;
   lda       = 2*ndiagL+ndiagU+1;
   A         = Ap;
-  defined   = true;
+   this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
-  info      = 0; 
+  info      = 0;
 
 } // DefineMatrix.
 
 
 template<class ARTYPE, class ARFLOAT>
 inline ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
-ARbdNonSymMatrix(int np, int ndiagLp, 
+ARbdNonSymMatrix(int np, int ndiagLp,
                  int ndiagUp, ARTYPE* Ap) : ARMatrix<ARTYPE>(np)
 {
 
   factored = false;
-  DefineMatrix(np, ndiagLp, ndiagUp, Ap);
+  this->DefineMatrix(np, ndiagLp, ndiagUp, Ap);
 
 } // Long constructor.
 
@@ -420,7 +420,7 @@ operator=(const ARbdNonSymMatrix<ARTYPE,
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+     this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbnspen.h /usr/local/include/arpack++/arbnspen.h
--- arpack++/include/arbnspen.h	2000-02-20 18:34:00.000000000 +0530
+++ /usr/local/include/arpack++/arbnspen.h	2016-11-17 18:22:42.132889211 +0530
@@ -42,10 +42,10 @@ class ARbdNonSymPencil
 
   int min(int a, int b) { return (a<b)?a:b; }
 
-  void ComplexCopy(int n, ARFLOAT dx[], int incx, 
+  void ComplexCopy(int n, ARFLOAT dx[], int incx,
                    arcomplex<ARFLOAT> dy[], int incy);
 
-  void ComplexAxpy(int n, arcomplex<ARFLOAT> da, ARTYPE dx[], 
+  void ComplexAxpy(int n, arcomplex<ARFLOAT> da, ARTYPE dx[],
                    int incx, arcomplex<ARFLOAT> dy[], int incy);
 
   virtual void Copy(const ARbdNonSymPencil& other);
@@ -82,13 +82,13 @@ class ARbdNonSymPencil
 
   void MultInvAsBv(ARFLOAT* v, ARFLOAT* w);
 
-  void DefineMatrices(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  void DefineMatrices(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                       ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
 
   ARbdNonSymPencil() { part = 'N'; }
   // Short constructor that does nothing.
 
-  ARbdNonSymPencil(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  ARbdNonSymPencil(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                    ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
   // Long constructor.
 
@@ -174,7 +174,7 @@ void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
       copy(AsB.n, &B->A[i], incb, &AsB.Ainv[AsB.ndiagL+i], AsB.lda);
       scal(AsB.n, negsig, &AsB.Ainv[AsB.ndiagL+i], AsB.lda);
     }
-  } 
+  }
 
   // Subtracting sigma*B from A.
 
@@ -184,7 +184,7 @@ void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
   begAsB = AsB.ndiagL+AsB.ndiagU-minU;
 
   for (i = 0; i < minL+minU+1; i++) {
-    axpy(AsB.n, -sigma, &B->A[begB+i], incb, &AsB.Ainv[begAsB+i], AsB.lda);  
+    axpy(AsB.n, -sigma, &B->A[begB+i], incb, &AsB.Ainv[begAsB+i], AsB.lda);
   }
 
   // Transferring part of B (*(-sigma)) if AsB.ndiagL > A->ndiagL.
@@ -196,7 +196,7 @@ void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
       copy(AsB.n, &B->A[begB+i], incb, &AsB.Ainv[begAsB+i], AsB.lda);
       scal(AsB.n, negsig, &AsB.Ainv[begAsB+i], AsB.lda);
     }
-  } 
+  }
 
 } // SubtractAsB (ARTYPE shift).
 
@@ -229,7 +229,7 @@ SubtractAsB(ARFLOAT sigmaR, ARFLOAT sigm
                   &AsBc.Ainv[AsBc.ndiagL+i], AsBc.lda);
       scal(AsBc.n, -sigma, &AsBc.Ainv[AsBc.ndiagL+i], AsBc.lda);
     }
-  } 
+  }
 
   // Subtracting sigma*B from A.
 
@@ -239,8 +239,8 @@ SubtractAsB(ARFLOAT sigmaR, ARFLOAT sigm
   begAsB = AsBc.ndiagL+AsBc.ndiagU-minU;
 
   for (i = 0; i < minL+minU+1; i++) {
-    ComplexAxpy(AsBc.n, -sigma, &B->A[begB+i], incb, 
-                &AsBc.Ainv[begAsB+i], AsBc.lda);  
+    ComplexAxpy(AsBc.n, -sigma, &B->A[begB+i], incb,
+                &AsBc.Ainv[begAsB+i], AsBc.lda);
   }
 
   // Transferring part of B (*(-sigma)) if AsBc.ndiagL > A->ndiagL.
@@ -296,7 +296,7 @@ void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
 
   // Reserving memory for some vectors used in matrix decomposition.
 
-  AsB.CreateStructure(); 
+  AsB.CreateStructure();
 
   // Subtracting sigma*B from A and storing the result on AsB.
 
@@ -354,7 +354,7 @@ FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI
 
   // Decomposing AsBc.
 
-  gbtrf(AsBc.n, AsBc.n, AsBc.ndiagL, AsBc.ndiagU, 
+  gbtrf(AsBc.n, AsBc.n, AsBc.ndiagL, AsBc.ndiagU,
         AsBc.Ainv, AsBc.lda, AsBc.ipiv, AsBc.info);
 
   // Handling errors.
@@ -433,7 +433,7 @@ void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARbdNonSymPencil<ARTYPE, ARFLOAT>::
-DefineMatrices(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+DefineMatrices(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
@@ -445,11 +445,11 @@ DefineMatrices(ARbdNonSymMatrix<ARTYPE,
 
 template<class ARTYPE, class ARFLOAT>
 inline ARbdNonSymPencil<ARTYPE, ARFLOAT>::
-ARbdNonSymPencil(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+ARbdNonSymPencil(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                  ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/arbscomp.h /usr/local/include/arpack++/arbscomp.h
--- arpack++/include/arbscomp.h	2000-02-20 18:59:32.000000000 +0530
+++ /usr/local/include/arpack++/arbscomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBSComp.h.
-   Arpack++ class ARluCompStdEig definition
+   Arpack++ class ARbdCompStdEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,7 +18,7 @@
 #ifndef ARBSCOMP_H
 #define ARBSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arscomp.h"
 #include "arbnsmat.h"
@@ -26,7 +26,7 @@
 
 
 template<class ARFLOAT>
-class ARluCompStdEig:
+class ARbdCompStdEig:
   public virtual ARCompStdEig<ARFLOAT,
                               ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> > {
 
@@ -44,86 +44,86 @@ class ARluCompStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluCompStdEig() { }
+  ARbdCompStdEig() { }
   // Short constructor.
 
-  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
-                 char* whichp = "LM", int ncvp = 0,
+  ARbdCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+  ARbdCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }
+  ARbdCompStdEig(const ARbdCompStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompStdEig() { }
+  virtual ~ARbdCompStdEig() { }
   // Destructor.
 
 
  // b) Operators.
 
-  ARluCompStdEig& operator=(const ARluCompStdEig& other);
+  ARbdCompStdEig& operator=(const ARbdCompStdEig& other);
   // Assignment operator.
 
-}; // class ARluCompStdEig.
+}; // class ARbdCompStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompStdEig member functions definition.                              //
+// ARbdCompStdEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARbdCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()
+inline void ARbdCompStdEig<ARFLOAT>::SetRegularMode()
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
-    SetRegularMode(objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARbdCompStdEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               char* whichp, int ncvp, ARFLOAT tolp,
+inline ARbdCompStdEig<ARFLOAT>::
+ARbdCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -131,29 +131,29 @@ ARluCompStdEig(int nevp, ARbdNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+inline ARbdCompStdEig<ARFLOAT>::
+ARbdCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluCompStdEig<ARFLOAT>& ARluCompStdEig<ARFLOAT>::
-operator=(const ARluCompStdEig<ARFLOAT>& other)
+ARbdCompStdEig<ARFLOAT>& ARbdCompStdEig<ARFLOAT>::
+operator=(const ARbdCompStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbsmat.h /usr/local/include/arpack++/arbsmat.h
--- arpack++/include/arbsmat.h	2000-02-20 18:16:20.000000000 +0530
+++ /usr/local/include/arpack++/arbsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,7 @@
 #ifndef ARBSMAT_H
 #define ARBSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -45,7 +45,7 @@ class ARbdSymMatrix: public ARMatrix<ART
   ARTYPE*  A;
   ARTYPE*  Ainv;
 
-  void ClearMem(); 
+  void ClearMem();
 
   virtual void Copy(const ARbdSymMatrix& other);
 
@@ -56,7 +56,7 @@ class ARbdSymMatrix: public ARMatrix<ART
   void CreateStructure();
 
   void ThrowError();
-  
+
  public:
 
   bool IsFactored() { return factored; }
@@ -95,11 +95,11 @@ class ARbdSymMatrix: public ARMatrix<ART
 
 template<class ARTYPE>
 inline void ARbdSymMatrix<ARTYPE>::ClearMem()
-{ 
+{
 
   if (factored) {
     delete[] Ainv;
-    delete[] ipiv; 
+    delete[] ipiv;
     Ainv = NULL;
     ipiv = NULL;
   }
@@ -114,9 +114,9 @@ Copy(const ARbdSymMatrix<ARTYPE>& other)
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   uplo      = other.uplo;
   nsdiag    = other.nsdiag;
@@ -130,11 +130,11 @@ Copy(const ARbdSymMatrix<ARTYPE>& other)
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[n*lda];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->n*lda];
+  ipiv = new int[this->n];
 
-  copy(n*lda, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy(this->n*lda, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -144,18 +144,18 @@ void ARbdSymMatrix<ARTYPE>::ExpandA()
 {
 
   int i;
- 
+
   if (uplo == 'U') {
 
     // Copying the main diagonal of A to Ainv.
 
-    copy(n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
+    copy(this->n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
 
     // Copying the superdiagonals of A to Ainv.
 
     for (i = 0; i < nsdiag; i++) {
-      copy(n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
-      copy(n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1, 
+      copy(this->n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
+      copy(this->n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1,
            &Ainv[3*nsdiag-i], lda);
     }
 
@@ -164,13 +164,13 @@ void ARbdSymMatrix<ARTYPE>::ExpandA()
 
     // Copying the main diagonal of A to Ainv.
 
-    copy(n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
+    copy(this->n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
 
     // Copying the subdiagonals of A to Ainv.
 
     for (i = 1; i <= nsdiag; i++) {
-      copy(n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
-      copy(n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
+      copy(this->n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
+      copy(this->n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
     }
 
   }
@@ -188,7 +188,7 @@ void ARbdSymMatrix<ARTYPE>::SubtractAsI(
 
   // Subtracting sigma from diagonal elements.
 
-  for (int i=(2*nsdiag); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
+  for (int i=(2*nsdiag); i<(lda*this->n); i+=lda) Ainv[i] -= sigma;
 
 } // SubtractAsI.
 
@@ -198,8 +198,8 @@ inline void ARbdSymMatrix<ARTYPE>::Creat
 {
 
   ClearMem();
-  Ainv = new ARTYPE[lda*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[lda*this->n];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -226,7 +226,7 @@ void ARbdSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorA");
   }
 
@@ -240,7 +240,7 @@ void ARbdSymMatrix<ARTYPE>::FactorA()
 
   // Decomposing A.
 
-  gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
+  gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -257,7 +257,7 @@ void ARbdSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorAsI");
   }
 
@@ -271,7 +271,7 @@ void ARbdSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
+  gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -291,13 +291,13 @@ void ARbdSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  sbmv(&uplo, n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
+  sbmv(&uplo, this->n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
 
 } // MultMv.
 
@@ -315,11 +315,11 @@ void ARbdSymMatrix<ARTYPE>::MultInvv(ART
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  gbtrs("N", n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, m, info);
+  gbtrs(APP_C_STR("N"), this->n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, this->m, info);
 
   // Handling errors.
 
@@ -335,28 +335,28 @@ DefineMatrix(int np, int nsdiagp, ARTYPE
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nsdiag    = nsdiagp;
   lda       = 3*nsdiag+1;
   uplo      = uplop;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
-  info      = 0; 
+  info      = 0;
 
 } // DefineMatrix.
 
 
 template<class ARTYPE>
 inline ARbdSymMatrix<ARTYPE>::
-ARbdSymMatrix(int np, int nsdiagp, 
+ARbdSymMatrix(int np, int nsdiagp,
               ARTYPE* Ap, char uplop) : ARMatrix<ARTYPE>(np)
 {
 
   factored = false;
-  DefineMatrix(np, nsdiagp, Ap, uplop);
+  this->DefineMatrix(np, nsdiagp, Ap, uplop);
 
 } // Long constructor.
 
@@ -367,7 +367,7 @@ operator=(const ARbdSymMatrix<ARTYPE>& o
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arbsnsym.h /usr/local/include/arpack++/arbsnsym.h
--- arpack++/include/arbsnsym.h	2000-02-20 18:44:28.000000000 +0530
+++ /usr/local/include/arpack++/arbsnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBSNSym.h.
-   Arpack++ class ARluNonSymStdEig definition
+   Arpack++ class ARbdNonSymStdEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,14 +18,14 @@
 #ifndef ARBSNSYM_H
 #define ARBSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arsnsym.h"
 #include "arbnsmat.h"
 
 
 template<class ARFLOAT>
-class ARluNonSymStdEig:
+class ARbdNonSymStdEig:
   public virtual ARNonSymStdEig<ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> > {
 
  public:
@@ -42,87 +42,87 @@ class ARluNonSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluNonSymStdEig() { }
+  ARbdNonSymStdEig() { }
   // Short constructor.
 
-  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   char* whichp = "LM", int ncvp = 0,
+  ARbdNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARbdNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }
+  ARbdNonSymStdEig(const ARbdNonSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymStdEig() { }
+  virtual ~ARbdNonSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluNonSymStdEig& operator=(const ARluNonSymStdEig& other);
+  ARbdNonSymStdEig& operator=(const ARbdNonSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymStdEig.
+}; // class ARbdNonSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymStdEig member functions definition.                            //
+// ARbdNonSymStdEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::
+inline void ARbdNonSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+   this->sigmaR    = sigmaRp;
+   this->sigmaI    = 0.0;
+   this->mode      = 3;
+   this->iparam[7] =  this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+   this->objOP->FactorAsI( this->sigmaR);
+   this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARbdNonSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode( this->objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARbdNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap,  this->objOP,
                        &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+inline ARbdNonSymStdEig<ARFLOAT>::
+ARbdNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, 
+   this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &(ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv),
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -130,28 +130,28 @@ ARluNonSymStdEig(int nevp, ARbdNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARbdNonSymStdEig<ARFLOAT>::
+ARbdNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluNonSymStdEig<ARFLOAT>& ARluNonSymStdEig<ARFLOAT>::
-operator=(const ARluNonSymStdEig<ARFLOAT>& other)
+ARbdNonSymStdEig<ARFLOAT>& ARbdNonSymStdEig<ARFLOAT>::
+operator=(const ARbdNonSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+     this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -160,4 +160,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARBSNSYM_H
-
diff -rupN arpack++/include/arbspen.h /usr/local/include/arpack++/arbspen.h
--- arpack++/include/arbspen.h	2000-02-20 18:18:26.000000000 +0530
+++ /usr/local/include/arpack++/arbspen.h	2016-11-17 18:22:42.132889211 +0530
@@ -117,7 +117,7 @@ void ARbdSymPencil<ARTYPE>::SubtractAsB(
 
     for (i = 0; i < ndA; i++) {
       copy(n, &A->A[i], ndA+1, &AsB.Ainv[2*ndAsB-ndA+i], lda);
-      copy(n-ndA+i, &A->A[i+(ndA-i)*(ndA+1)], ndA+1, 
+      copy(n-ndA+i, &A->A[i+(ndA-i)*(ndA+1)], ndA+1,
            &AsB.Ainv[2*ndAsB+ndA-i], lda);
     }
 
@@ -147,7 +147,7 @@ void ARbdSymPencil<ARTYPE>::SubtractAsB(
         copy(n, &B->A[i], ndB+1, &AsB.Ainv[ndAsB+i], lda);
         scal(n, negsig, &AsB.Ainv[ndAsB+i], lda);
         copy(n-ndAsB+i, &AsB.Ainv[ndAsB+i+(ndAsB-i)*lda], lda,
-             &AsB.Ainv[lda-i-1], lda);  
+             &AsB.Ainv[lda-i-1], lda);
       }
 
     }
@@ -156,13 +156,13 @@ void ARbdSymPencil<ARTYPE>::SubtractAsB(
       for (i = ndA+1; i <= ndAsB; i++) {
         copy(n, &B->A[i], ndB+1, &AsB.Ainv[2*ndAsB+i], lda);
         scal(n, negsig, &AsB.Ainv[2*ndAsB+i], lda);
-        copy(n-i, &AsB.Ainv[2*ndAsB+i], lda, 
+        copy(n-i, &AsB.Ainv[2*ndAsB+i], lda,
              &AsB.Ainv[2*ndAsB-i+i*lda], lda);
       }
 
     }
 
-  } 
+  }
 
   // Subtracting sigma*B from A.
 
@@ -177,10 +177,10 @@ void ARbdSymPencil<ARTYPE>::SubtractAsB(
     // Subtracting the superdiagonals.
 
     for (i = 0; i < minD; i++) {
-      axpy(n, negsig, &B->A[ndB-minD+i], ndB+1, 
+      axpy(n, negsig, &B->A[ndB-minD+i], ndB+1,
            &AsB.Ainv[2*ndAsB-minD+i], lda);
       copy(n-minD+i, &AsB.Ainv[2*ndAsB-minD+i+(minD-i)*lda], lda,
-           &AsB.Ainv[2*ndAsB+minD-i], lda);  
+           &AsB.Ainv[2*ndAsB+minD-i], lda);
     }
 
   }
@@ -194,10 +194,10 @@ void ARbdSymPencil<ARTYPE>::SubtractAsB(
 
     for (i = 1; i <= minD; i++) {
       axpy(n, negsig, &B->A[i], ndB+1, &AsB.Ainv[2*ndAsB+i], lda);
-      copy(n-i, &AsB.Ainv[2*ndAsB+i], lda, 
+      copy(n-i, &AsB.Ainv[2*ndAsB+i], lda,
            &AsB.Ainv[2*ndAsB-i+i*lda], lda);
     }
-   
+
   }
 
 } // SubtractAsB (ARTYPE shift).
@@ -232,7 +232,7 @@ void ARbdSymPencil<ARTYPE>::FactorAsB(AR
 
   // Reserving memory for some vectors used in matrix decomposition.
 
-  AsB.CreateStructure(); 
+  AsB.CreateStructure();
 
   // Subtracting sigma*B from A and storing the result on AsB.
 
@@ -240,7 +240,7 @@ void ARbdSymPencil<ARTYPE>::FactorAsB(AR
 
   // Decomposing AsB.
 
-  gbtrf(AsB.n, AsB.n, AsB.nsdiag, AsB.nsdiag, 
+  gbtrf(AsB.n, AsB.n, AsB.nsdiag, AsB.nsdiag,
         AsB.Ainv, AsB.lda, AsB.ipiv, AsB.info);
 
   // Handling errors.
@@ -282,7 +282,7 @@ ARbdSymPencil(ARbdSymMatrix<ARTYPE>& Ap,
 {
 
   AsB.factored  = false;
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/arbssym.h /usr/local/include/arpack++/arbssym.h
--- arpack++/include/arbssym.h	2000-02-20 18:38:20.000000000 +0530
+++ /usr/local/include/arpack++/arbssym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARBSSym.h.
-   Arpack++ class ARluSymStdEig definition
+   Arpack++ class ARbdSymStdEig definition
    (band matrix version).
 
    ARPACK Authors
@@ -18,14 +18,14 @@
 #ifndef ARBSSYM_H
 #define ARBSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arssym.h"
 #include "arbsmat.h"
 
 
 template<class ARFLOAT>
-class ARluSymStdEig:
+class ARbdSymStdEig:
   public virtual ARSymStdEig<ARFLOAT, ARbdSymMatrix<ARFLOAT> > {
 
  public:
@@ -42,112 +42,112 @@ class ARluSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluSymStdEig() { }
+  ARbdSymStdEig() { }
   // Short constructor.
 
-  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-                char* whichp = "LM", int ncvp = 0,
+  ARbdSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+                const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-                ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARbdSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+                ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }
+  ARbdSymStdEig(const ARbdSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymStdEig() { }
+  virtual ~ARbdSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluSymStdEig& operator=(const ARluSymStdEig& other);
+  ARbdSymStdEig& operator=(const ARbdSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluSymStdEig.
+}; // class ARbdSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymStdEig member functions definition.                               //
+// ARbdSymStdEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::
+inline void ARbdSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARbdSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARbdSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-              char* whichp, int ncvp, ARFLOAT tolp,
+inline ARbdSymStdEig<ARFLOAT>::
+ARbdSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultMv,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
-              ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARbdSymStdEig<ARFLOAT>::
+ARbdSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
+              ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultInvv,
+  this->DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluSymStdEig<ARFLOAT>& ARluSymStdEig<ARFLOAT>::
-operator=(const ARluSymStdEig<ARFLOAT>& other)
+ARbdSymStdEig<ARFLOAT>& ARbdSymStdEig<ARFLOAT>::
+operator=(const ARbdSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -156,4 +156,3 @@ operator=(const ARluSymStdEig<ARFLOAT>&
 
 
 #endif // ARBSSYM_H
-
diff -rupN arpack++/include/arch.h /usr/local/include/arpack++/arch.h
--- arpack++/include/arch.h	2000-03-04 02:05:38.000000000 +0530
+++ /usr/local/include/arpack++/arch.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,7 @@
 #define ARCH_H
 
 // ARPACK++ arcomplex type definition.
-// If you are not using g++ (or CC) and also are not intending 
+// If you are not using g++ (or CC) and also are not intending
 // use complex variables, comment out the following line.
 
 #include "arcomp.h"
@@ -29,10 +29,10 @@
 // If the Standard Template Library is not available at your system
 // and you do not want to install it, comment out the following line.
 
-#include <vector.h>
+#include <vector>
 
 // If your STL vector class defines a variable other than
-// __SGI_STL_VECTOR_H, please change this variable name 
+// __SGI_STL_VECTOR_H, please change this variable name
 // in the ifdef command below.
 
 #ifdef __SGI_STL_VECTOR_H
@@ -42,8 +42,8 @@
 // UMFPACK parameters.
 // These parameters are used by UMFPACK library functions. Normally
 // they are not modified by the user. To use the default value, set
-// the parameter to zero. For a complete description of all UMFPACK 
-// parameters, see the library documentation. 
+// the parameter to zero. For a complete description of all UMFPACK
+// parameters, see the library documentation.
 
 #define UICNTL7 0 // icntl(7). Block size for the blas (machine-dependent).
 #define UICNTL5 0 // icntl(5). Number of columns to examine during pivot search.
@@ -63,7 +63,7 @@
 #if  defined(RIOS) && !defined(CLAPACK)
 #define F77NAME(x) x
 #else
-// #include <generic.h> 
+// #include <generic.h>
 // #define F77NAME(x) name2(x,_)
 #define F77NAME(x) x ## _
 #endif
@@ -91,5 +91,8 @@ typedef int ARlogical;
 
 #endif
 
+// SC: Squash "deprecated conversion from string constant to char*" warnings
+#include <string>
+#define APP_C_STR( text ) (const_cast<char *>(std::string( text ).c_str()))
 
 #endif // ARCH_H
diff -rupN arpack++/include/arcomp.h /usr/local/include/arpack++/arcomp.h
--- arpack++/include/arcomp.h	2000-02-20 18:35:08.000000000 +0530
+++ /usr/local/include/arpack++/arcomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -17,11 +17,11 @@
 #ifndef ARCOMP_H
 #define ARCOMP_H
 
-#include <complex.h>
+#include <complex>
 
 #ifdef __GNUG__
   
-#define arcomplex complex
+#define arcomplex std::complex
 
 #endif
 
diff -rupN arpack++/include/ardfmat.h /usr/local/include/arpack++/ardfmat.h
--- arpack++/include/ardfmat.h	2000-02-22 01:30:20.000000000 +0530
+++ /usr/local/include/arpack++/ardfmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -19,11 +19,11 @@
 #ifndef ARDFMAT_H
 #define ARDFMAT_H
 
-#include <stddef.h>
-#include <fstream.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstddef>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 #include "arch.h"
 #include "arerror.h"
 
@@ -36,7 +36,7 @@ class ARdfMatrix {
   // const int linelength = 256;
 
   char*    datafile;  // Filename.
-  ifstream file;      // File handler.
+  std::ifstream file;      // File handler.
   int      m;         // Number of rows.
   int      n;         // Number of columns.
   int      blksize;   // Size of each matrix block that is read at once.
@@ -55,13 +55,13 @@ class ARdfMatrix {
 
   void SetComplexPointers(char* num, char* &realp, char* &imagp);
 			  			  
-  bool ReadEntry(ifstream& file, double& val);
+  bool ReadEntry(std::ifstream& file, double& val);
 
-  bool ReadEntry(ifstream& file, float& val);
+  bool ReadEntry(std::ifstream& file, float& val);
 
-  bool ReadEntry(ifstream& file, arcomplex<double>& val);
+  bool ReadEntry(std::ifstream& file, arcomplex<double>& val);
 
-  bool ReadEntry(ifstream& file, arcomplex<float>& val);
+  bool ReadEntry(std::ifstream& file, arcomplex<float>& val);
   
  public:
   
@@ -145,7 +145,7 @@ SetComplexPointers(char* num, char* &rea
 
 
 template<class ARTYPE>
-inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, double& val)
+inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, double& val)
 {
 
   char num[LINELEN];
@@ -165,7 +165,7 @@ inline bool ARdfMatrix<ARTYPE>::ReadEntr
 
 
 template<class ARTYPE>
-inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, float& val)
+inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, float& val)
 {
 
   double dval;
@@ -180,7 +180,7 @@ inline bool ARdfMatrix<ARTYPE>::ReadEntr
 
 template<class ARTYPE>
 inline bool ARdfMatrix<ARTYPE>::
-ReadEntry(ifstream& file, arcomplex<double>& val)
+ReadEntry(std::ifstream& file, arcomplex<double>& val)
 {
 
   char  num[LINELEN];
@@ -204,7 +204,7 @@ ReadEntry(ifstream& file, arcomplex<doub
 
 template<class ARTYPE>
 inline bool ARdfMatrix<ARTYPE>::
-ReadEntry(ifstream& file, arcomplex<float>& val)
+ReadEntry(std::ifstream& file, arcomplex<float>& val)
 {
 
   char  num[LINELEN];
diff -rupN arpack++/include/ardgcomp.h /usr/local/include/arpack++/ardgcomp.h
--- arpack++/include/ardgcomp.h	2000-02-21 05:00:26.000000000 +0530
+++ /usr/local/include/arpack++/ardgcomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDGComp.h.
-   Arpack++ class ARluCompGenEig definition
+   Arpack++ class ARdsCompGenEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARDGCOMP_H
 #define ARDGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardnsmat.h"
 #include "ardnspen.h"
@@ -27,7 +28,7 @@
 
 
 template<class ARFLOAT>
-class ARluCompGenEig:
+class ARdsCompGenEig:
   public virtual
     ARCompGenEig<ARFLOAT, ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                  ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > > {
@@ -40,7 +41,7 @@ class ARluCompGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluCompGenEig& other);
+  virtual void Copy(const ARdsCompGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -60,68 +61,68 @@ class ARluCompGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluCompGenEig() { }
+  ARdsCompGenEig() { }
   // Short constructor.
 
-  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARdsCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 char* whichp = "LM", int ncvp = 0,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARdsCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }
+  ARdsCompGenEig(const ARdsCompGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompGenEig() { }
+  virtual ~ARdsCompGenEig() { }
 
  // d) Operators.
 
-  ARluCompGenEig& operator=(const ARluCompGenEig& other);
+  ARdsCompGenEig& operator=(const ARdsCompGenEig& other);
   // Assignment operator.
 
-}; // class ARluCompGenEig.
+}; // class ARdsCompGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompGenEig member functions definition.                              //
+// ARdsCompGenEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
-Copy(const ARluCompGenEig<ARFLOAT>& other)
+inline void ARdsCompGenEig<ARFLOAT>::
+Copy(const ARdsCompGenEig<ARFLOAT>& other)
 {
 
   ARCompGenEig<ARFLOAT, ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARdsCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()
+inline void ARdsCompGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
@@ -133,7 +134,7 @@ inline void ARluCompGenEig<ARFLOAT>::Set
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARdsCompGenEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
@@ -146,19 +147,19 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
+inline ARdsCompGenEig<ARFLOAT>::
+ARdsCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp,
                arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
-                   &Pencil, 
+                   &Pencil,
                    &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -166,19 +167,19 @@ ARluCompGenEig(int nevp, ARdsNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+inline ARdsCompGenEig<ARFLOAT>::
+ARdsCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
-                   &Pencil, 
+                   &Pencil,
                    &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
   SetShiftInvertMode(sigmap);
@@ -187,12 +188,12 @@ ARluCompGenEig(int nevp, ARdsNonSymMatri
 
 
 template<class ARFLOAT>
-ARluCompGenEig<ARFLOAT>& ARluCompGenEig<ARFLOAT>::
-operator=(const ARluCompGenEig<ARFLOAT>& other)
+ARdsCompGenEig<ARFLOAT>& ARdsCompGenEig<ARFLOAT>::
+operator=(const ARdsCompGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ardgnsym.h /usr/local/include/arpack++/ardgnsym.h
--- arpack++/include/ardgnsym.h	2000-02-21 04:48:48.000000000 +0530
+++ /usr/local/include/arpack++/ardgnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDGNSym.h.
-   Arpack++ class ARluNonSymGenEig definition
+   Arpack++ class ARdsNonSymGenEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARDGNSYM_H
 #define ARDGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardnsmat.h"
 #include "ardnspen.h"
@@ -26,7 +27,7 @@
 
 
 template<class ARFLOAT>
-class ARluNonSymGenEig:
+class ARdsNonSymGenEig:
   public virtual ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
                                 ARdsNonSymPencil<ARFLOAT, ARFLOAT> > {
 
@@ -38,7 +39,7 @@ class ARluNonSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluNonSymGenEig& other);
+  virtual void Copy(const ARdsNonSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -60,73 +61,73 @@ class ARluNonSymGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluNonSymGenEig() { }
+  ARdsNonSymGenEig() { }
   // Short constructor.
 
-  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
+  ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
-                   char* whichp = "LM", int ncvp = 0,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (real shift and invert mode).
 
-  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
-                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
+                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
 
-  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }
+  ARdsNonSymGenEig(const ARdsNonSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymGenEig() { }
+  virtual ~ARdsNonSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluNonSymGenEig& operator=(const ARluNonSymGenEig& other);
+  ARdsNonSymGenEig& operator=(const ARdsNonSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymGenEig.
+}; // class ARdsNonSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymGenEig member functions definition.                            //
+// ARdsNonSymGenEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
-Copy(const ARluNonSymGenEig<ARFLOAT>& other)
+inline void ARdsNonSymGenEig<ARFLOAT>::
+Copy(const ARdsNonSymGenEig<ARFLOAT>& other)
 {
 
   ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARdsNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARdsNonSymGenEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -134,7 +135,7 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARdsNonSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT> >::
@@ -144,7 +145,7 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARdsNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
@@ -156,7 +157,7 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARdsNonSymGenEig<ARFLOAT>::
 SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
@@ -170,16 +171,16 @@ SetComplexShiftMode(char partp, ARFLOAT
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
+inline ARdsNonSymGenEig<ARFLOAT>::
+ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -188,16 +189,16 @@ ARluNonSymGenEig(int nevp, ARdsNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+inline ARdsNonSymGenEig<ARFLOAT>::
+ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                  ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -207,17 +208,17 @@ ARluNonSymGenEig(int nevp, ARdsNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
-                 char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp, 
-                 int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp, 
+inline ARdsNonSymGenEig<ARFLOAT>::
+ARdsNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B,
+                 char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp,
+                 int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp,
                  bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -227,12 +228,12 @@ ARluNonSymGenEig(int nevp, ARdsNonSymMat
 
 
 template<class ARFLOAT>
-ARluNonSymGenEig<ARFLOAT>& ARluNonSymGenEig<ARFLOAT>::
-operator=(const ARluNonSymGenEig<ARFLOAT>& other)
+ARdsNonSymGenEig<ARFLOAT>& ARdsNonSymGenEig<ARFLOAT>::
+operator=(const ARdsNonSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ardgsym.h /usr/local/include/arpack++/ardgsym.h
--- arpack++/include/ardgsym.h	2000-02-21 04:41:24.000000000 +0530
+++ /usr/local/include/arpack++/ardgsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDGSym.h.
-   Arpack++ class ARluSymGenEig definition
+   Arpack++ class ARdsSymGenEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARDGSYM_H
 #define ARDGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardsmat.h"
 #include "ardspen.h"
@@ -26,7 +27,7 @@
 
 
 template<class ARFLOAT>
-class ARluSymGenEig:
+class ARdsSymGenEig:
   public virtual ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>,
                              ARdsSymPencil<ARFLOAT> > {
 
@@ -38,7 +39,7 @@ class ARluSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluSymGenEig& other);
+  virtual void Copy(const ARdsSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -62,67 +63,67 @@ class ARluSymGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluSymGenEig() { }
+  ARdsSymGenEig() { }
   // Short constructor.
 
-  ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-                ARdsSymMatrix<ARFLOAT>& B, char* whichp = "LM",
+  ARdsSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+                ARdsSymMatrix<ARFLOAT>& B, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
-                ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
+  ARdsSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
+                ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert, buckling and Cayley modes).
 
-  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }
+  ARdsSymGenEig(const ARdsSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymGenEig() { }
+  virtual ~ARdsSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluSymGenEig& operator=(const ARluSymGenEig& other);
+  ARdsSymGenEig& operator=(const ARdsSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluSymGenEig.
+}; // class ARdsSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymGenEig member functions definition.                               //
+// ARdsSymGenEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
-Copy(const ARluSymGenEig<ARFLOAT>& other)
+inline void ARdsSymGenEig<ARFLOAT>::
+Copy(const ARdsSymGenEig<ARFLOAT>& other)
 {
 
   ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>,
               ARdsSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
+inline void ARdsSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARdsSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsSymPencil<ARFLOAT> >::
@@ -132,7 +133,7 @@ inline void ARluSymGenEig<ARFLOAT>::SetR
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARdsSymGenEig<ARFLOAT>::
 SetShiftInvertMode(ARFLOAT sigmap)
 {
 
@@ -144,7 +145,7 @@ SetShiftInvertMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARdsSymGenEig<ARFLOAT>::
 SetBucklingMode(ARFLOAT sigmap)
 {
 
@@ -156,7 +157,7 @@ SetBucklingMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARdsSymGenEig<ARFLOAT>::
 SetCayleyMode(ARFLOAT sigmap)
 {
 
@@ -169,17 +170,17 @@ SetCayleyMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-              ARdsSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
+inline ARdsSymGenEig<ARFLOAT>::
+ARdsSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+              ARdsSymMatrix<ARFLOAT>& B, const char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->InvertMode = 'S';
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -188,25 +189,25 @@ ARluSymGenEig(int nevp, ARdsSymMatrix<AR
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
+inline ARdsSymGenEig<ARFLOAT>::
+ARdsSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
               ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
-              char* whichp, int ncvp, ARFLOAT tolp,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':
     ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
   case 'S':
-    ChangeShift(sigmap);
+    this->ChangeShift(sigmap);
     break;
   case 'C':
     SetCayleyMode(sigmap);
@@ -216,12 +217,12 @@ ARluSymGenEig(char InvertModep, int nevp
 
 
 template<class ARFLOAT>
-ARluSymGenEig<ARFLOAT>& ARluSymGenEig<ARFLOAT>::
-operator=(const ARluSymGenEig<ARFLOAT>& other)
+ARdsSymGenEig<ARFLOAT>& ARdsSymGenEig<ARFLOAT>::
+operator=(const ARdsSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ardnsmat.h /usr/local/include/arpack++/ardnsmat.h
--- arpack++/include/ardnsmat.h	2000-02-22 01:28:26.000000000 +0530
+++ /usr/local/include/arpack++/ardnsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,8 @@
 #ifndef ARDNSMAT_H
 #define ARDNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -45,14 +46,14 @@ class ARdsNonSymMatrix: public ARMatrix<
   ARTYPE*             Ainv;
   ARdfMatrix<ARTYPE>  mat;
 
-  void ClearMem(); 
+  void ClearMem();
 
   virtual void Copy(const ARdsNonSymMatrix& other);
 
   void CreateStructure();
 
   void ThrowError();
-  
+
  public:
 
   bool IsFactored() { return factored; }
@@ -107,11 +108,11 @@ class ARdsNonSymMatrix: public ARMatrix<
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()
-{ 
+{
 
   if (factored) {
     delete[] Ainv;
-    delete[] ipiv; 
+    delete[] ipiv;
     Ainv = NULL;
     ipiv = NULL;
   }
@@ -126,9 +127,9 @@ Copy(const ARdsNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   info      = other.info;
   A         = other.A;
@@ -145,11 +146,11 @@ Copy(const ARdsNonSymMatrix<ARTYPE, ARFL
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[m*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->m*this->n];
+  ipiv = new int[this->n];
 
-  copy(m*n, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy(this->m*this->n, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -159,8 +160,8 @@ inline void ARdsNonSymMatrix<ARTYPE, ARF
 {
 
   ClearMem();
-  Ainv = new ARTYPE[m*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->m*this->n];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -187,11 +188,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined or is rectangular.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::FactorA");
   }
 
-  if (m!=n) {
+  if (this->m!=this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARdsNonSymMatrix::FactorA");
   }
@@ -207,11 +208,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Copying A to Ainv;
 
-  ::copy(m*n, A, 1, Ainv, 1);
+  ::copy(this->m*this->n, A, 1, Ainv, 1);
 
   // Decomposing A.
 
-  getrf(m, n, Ainv, m, ipiv, info);
+  getrf(this->m, this->n, Ainv, this->m, ipiv, info);
 
   // Handling errors.
 
@@ -228,12 +229,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined or is rectangular.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARdsNonSymMatrix::FactorAsI");
   }
 
-  if (m!=n) {
+  if (this->m!=this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARdsNonSymMatrix::FactorAsI");
   }
@@ -249,12 +250,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Subtracting sigma*I from A.
 
-  ::copy(m*n,A,1,Ainv,1);
-  for (int i=0; i<(m*n); i+=m+1) Ainv[i]-=sigma;
+  ::copy(this->m*this->n,A,1,Ainv,1);
+  for (int i=0; i<(this->m*this->n); i+=this->m+1) Ainv[i]-=sigma;
 
   // Decomposing AsI.
 
-  getrf(m, n, Ainv, m, ipiv, info);
+  getrf(this->m, this->n, Ainv, this->m, ipiv, info);
 
   // Handling errors.
 
@@ -279,7 +280,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMv");
   }
 
@@ -287,14 +288,14 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   if (mat.IsOutOfCore()) {
 
-    if (m>n) { 
+    if (this->m>this->n) {
 
       // Matrix is "tall".
 
       mat.Rewind();
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
+        gemv(APP_C_STR("N"), mat.RowsInMemory(), this->n, one, mat.Entries(),
              mat.RowsInMemory(), v, 1, zero, &w[mat.FirstIndex()], 1);
       }
 
@@ -305,12 +306,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
       mat.Rewind();
       t = new ARTYPE[mat.ColsInMemory()];
-      for (i=0; i<m; i++) w[i] = zero;
+      for (i=0; i<this->m; i++) w[i] = zero;
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
-             m, &v[mat.FirstIndex()], 1, zero, t, 1);
-        axpy(m, one, t, 1, w, 1); 
+        gemv(APP_C_STR("N"), this->m, mat.ColsInMemory(), one, mat.Entries(),
+             this->m, &v[mat.FirstIndex()], 1, zero, t, 1);
+        axpy(this->m, one, t, 1, w, 1);
       }
       delete[] t;
 
@@ -319,7 +320,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    gemv("N", m, n, one, A, m, v, 1, zero, w, 1);
+    gemv(APP_C_STR("N"), this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
 
   }
 
@@ -332,15 +333,15 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   int     i;
   ARTYPE* t;
-  ARTYPE  one;   
-  ARTYPE  zero; 
+  ARTYPE  one;
+  ARTYPE  zero;
 
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMtv");
   }
 
@@ -348,15 +349,15 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   if (mat.IsOutOfCore()) {
 
-    if (m<=n) { 
+    if (this->m<=this->n) {
 
       // Matrix is "fat".
 
       mat.Rewind();
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
-             m, v, 1, zero, &w[mat.FirstIndex()], 1);
+        gemv(APP_C_STR("T"), this->m, mat.ColsInMemory(), one, mat.Entries(),
+             this->m, v, 1, zero, &w[mat.FirstIndex()], 1);
       }
 
     }
@@ -366,12 +367,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
       mat.Rewind();
       t = new ARTYPE[mat.ColsInMemory()];
-      for (i=0; i<m; i++) w[i] = zero;
+      for (i=0; i<this->m; i++) w[i] = zero;
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
+        gemv(APP_C_STR("T"), mat.RowsInMemory(), this->n, one, mat.Entries(),
              mat.RowsInMemory(), &v[mat.FirstIndex()], 1, zero, t, 1);
-        axpy(mat.RowsInMemory(), one, t, 1, w, 1); 
+        axpy(mat.RowsInMemory(), one, t, 1, w, 1);
       }
       delete[] t;
 
@@ -380,7 +381,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    gemv("T", m, n, one, A, m, v, 1, zero, w, 1);
+    gemv(APP_C_STR("T"), this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
 
   }
 
@@ -394,28 +395,28 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   int    i;
   ARTYPE *t, *s;
-  ARTYPE one;   
-  ARTYPE zero; 
+  ARTYPE one;
+  ARTYPE zero;
 
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
-  if (mat.IsOutOfCore() && (m>n)) {
+  if (mat.IsOutOfCore() && (this->m>this->n)) {
 
     // Special code for "tall" matrices.
 
     t = new ARTYPE[mat.BlockSize()];
-    s = new ARTYPE[n];
+    s = new ARTYPE[this->n];
 
     mat.Rewind();
-    for (i=0; i<n; i++) w[i] = zero;
+    for (i=0; i<this->n; i++) w[i] = zero;
     for (i=0; i<mat.NBlocks(); i++) {
       mat.ReadBlock();
-      gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
+      gemv(APP_C_STR("N"), mat.RowsInMemory(), this->n, one, mat.Entries(),
            mat.RowsInMemory(), v, 1, zero, t, 1);
-      gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
+      gemv(APP_C_STR("T"), mat.RowsInMemory(), this->n, one, mat.Entries(),
            mat.RowsInMemory(), t, 1, zero, s, 1);
-      axpy(n, one, s, 1, w, 1); 
+      axpy(this->n, one, s, 1, w, 1);
 
     }
 
@@ -425,7 +426,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    t = new ARTYPE[m];
+    t = new ARTYPE[this->m];
 
     MultMv(v,t);
     MultMtv(t,w);
@@ -444,28 +445,28 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   int    i;
   ARTYPE *t, *s;
-  ARTYPE one;   
-  ARTYPE zero; 
+  ARTYPE one;
+  ARTYPE zero;
 
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
-  if (mat.IsOutOfCore() && (m<=n)) {
+  if (mat.IsOutOfCore() && (this->m<=this->n)) {
 
     // Special code for "fat" matrices.
 
     t = new ARTYPE[mat.BlockSize()];
-    s = new ARTYPE[m];
+    s = new ARTYPE[this->m];
 
     mat.Rewind();
-    for (i=0; i<m; i++) w[i] = zero;
+    for (i=0; i<this->m; i++) w[i] = zero;
     for (i=0; i<mat.NBlocks(); i++) {
       mat.ReadBlock();
-      gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
-           m, v, 1, zero, t, 1);
-      gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
-           m, t, 1, zero, s, 1);
-      axpy(m, one, s, 1, w, 1); 
+      gemv(APP_C_STR("T"), this->m, mat.ColsInMemory(), one, mat.Entries(),
+           this->m, v, 1, zero, t, 1);
+      gemv(APP_C_STR("N"), this->m, mat.ColsInMemory(), one, mat.Entries(),
+           this->m, t, 1, zero, s, 1);
+      axpy(this->m, one, s, 1, w, 1);
 
     }
 
@@ -475,7 +476,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    t = new ARTYPE[n];
+    t = new ARTYPE[this->n];
 
     MultMtv(v,t);
     MultMv(t,w);
@@ -491,8 +492,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -510,11 +511,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  getrs("N", n, 1, Ainv, m, ipiv, w, m, info);
+  getrs(APP_C_STR("N"), this->n, 1, Ainv, this->m, ipiv, w, this->m, info);
 
   // Handling errors.
 
@@ -530,13 +531,13 @@ DefineMatrix(int np, ARTYPE* Ap)
 
   // Defining member variables.
 
-  n         = np;
-  m         = np;
+  this->n         = np;
+  this->m         = np;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
-  info      = 0; 
+  info      = 0;
 
 } // DefineMatrix (square).
 
@@ -548,10 +549,10 @@ DefineMatrix(int mp, int np, ARTYPE* Ap)
 
   // Defining member variables.
 
-  m         = mp;
-  n         = np;
+  this->m         = mp;
+  this->n         = np;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0;
@@ -565,7 +566,7 @@ ARdsNonSymMatrix(int np, ARTYPE* Ap) : A
 {
 
   factored = false;
-  DefineMatrix(np, Ap);
+  this->DefineMatrix(np, Ap);
 
 } // Long constructor (square matrix).
 
@@ -576,7 +577,7 @@ ARdsNonSymMatrix(int mp, int np, ARTYPE*
 {
 
   factored = false;
-  DefineMatrix(mp, np, Ap);
+  this->DefineMatrix(mp, np, Ap);
 
 } // Long constructor (rectangular matrix).
 
@@ -595,10 +596,10 @@ ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ARdsN
   }
 
   if (mat.NCols() == mat.NRows()) {
-    DefineMatrix(mat.NCols(), (ARTYPE*)mat.Entries());
+    this->DefineMatrix(mat.NCols(), (ARTYPE*)mat.Entries());
   }
-  else {                             
-    DefineMatrix(mat.NRows(), mat.NCols(), (ARTYPE*)mat.Entries());
+  else {
+    this->DefineMatrix(mat.NRows(), mat.NCols(), (ARTYPE*)mat.Entries());
   }
 
 } // Long constructor (Matrix stored in a file).
diff -rupN arpack++/include/ardnspen.h /usr/local/include/arpack++/ardnspen.h
--- arpack++/include/ardnspen.h	2000-02-21 04:38:06.000000000 +0530
+++ /usr/local/include/arpack++/ardnspen.h	2016-11-17 18:22:42.132889211 +0530
@@ -66,13 +66,13 @@ class ARdsNonSymPencil
 
   void MultInvAsBv(ARFLOAT* v, ARFLOAT* w);
 
-  void DefineMatrices(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  void DefineMatrices(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                       ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
 
   ARdsNonSymPencil() { part = 'N'; }
   // Short constructor that does nothing.
 
-  ARdsNonSymPencil(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  ARdsNonSymPencil(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                    ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
   // Long constructor.
 
@@ -148,7 +148,7 @@ void ARdsNonSymPencil<ARTYPE, ARFLOAT>::
 
   // Subtracting sigma*B from A and storing the result on AsB.
 
-  ::copy(A->m*A->n, A->A, 1, AsB.Ainv, 1); 
+  ::copy(A->m*A->n, A->A, 1, AsB.Ainv, 1);
   axpy(A->m*A->n, -sigma, B->A, 1, AsB.Ainv, 1);
 
   // Decomposing AsB.
@@ -193,7 +193,7 @@ FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI
 
   // Reserving memory for some vectors used in matrix decomposition.
 
-  AsBc.CreateStructure(); 
+  AsBc.CreateStructure();
 
   // Subtracting sigma*B from A and storing the result on AsBc.
 
@@ -282,7 +282,7 @@ void ARdsNonSymPencil<ARTYPE, ARFLOAT>::
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARdsNonSymPencil<ARTYPE, ARFLOAT>::
-DefineMatrices(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+DefineMatrices(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
@@ -299,11 +299,11 @@ DefineMatrices(ARdsNonSymMatrix<ARTYPE,
 
 template<class ARTYPE, class ARFLOAT>
 inline ARdsNonSymPencil<ARTYPE, ARFLOAT>::
-ARdsNonSymPencil(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+ARdsNonSymPencil(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                  ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/ardscomp.h /usr/local/include/arpack++/ardscomp.h
--- arpack++/include/ardscomp.h	2000-02-21 04:52:42.000000000 +0530
+++ /usr/local/include/arpack++/ardscomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDSComp.h.
-   Arpack++ class ARluCompStdEig definition
+   Arpack++ class ARdsCompStdEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARDSCOMP_H
 #define ARDSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "ardnsmat.h"
@@ -26,8 +27,8 @@
 
 
 template<class ARFLOAT>
-class ARluCompStdEig:
-  public virtual ARCompStdEig<ARFLOAT, 
+class ARdsCompStdEig:
+  public virtual ARCompStdEig<ARFLOAT,
                               ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> > {
 
  public:
@@ -44,87 +45,87 @@ class ARluCompStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluCompStdEig() { }
+  ARdsCompStdEig() { }
   // Short constructor.
 
-  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
-                 char* whichp = "LM", int ncvp = 0,
+  ARdsCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+  ARdsCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }
+  ARdsCompStdEig(const ARdsCompStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompStdEig() { }
+  virtual ~ARdsCompStdEig() { }
   // Destructor.
 
 
  // b) Operators.
 
-  ARluCompStdEig& operator=(const ARluCompStdEig& other);
+  ARdsCompStdEig& operator=(const ARdsCompStdEig& other);
   // Assignment operator.
 
-}; // class ARluCompStdEig.
+}; // class ARdsCompStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompStdEig member functions definition.                              //
+// ARdsCompStdEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARdsCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()
+inline void ARdsCompStdEig<ARFLOAT>::SetRegularMode()
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP,
                    &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARdsCompStdEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARdsNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               char* whichp, int ncvp, ARFLOAT tolp,
+inline ARdsCompStdEig<ARFLOAT>::
+ARdsCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -132,29 +133,29 @@ ARluCompStdEig(int nevp, ARdsNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+inline ARdsCompStdEig<ARFLOAT>::
+ARdsCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluCompStdEig<ARFLOAT>& ARluCompStdEig<ARFLOAT>::
-operator=(const ARluCompStdEig<ARFLOAT>& other)
+ARdsCompStdEig<ARFLOAT>& ARdsCompStdEig<ARFLOAT>::
+operator=(const ARdsCompStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ardsmat.h /usr/local/include/arpack++/ardsmat.h
--- arpack++/include/ardsmat.h	2000-02-21 04:26:02.000000000 +0530
+++ /usr/local/include/arpack++/ardsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,8 @@
 #ifndef ARDSMAT_H
 #define ARDSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -43,7 +44,7 @@ class ARdsSymMatrix: public ARMatrix<ART
   ARTYPE*  A;
   ARTYPE*  Ainv;
 
-  void ClearMem(); 
+  void ClearMem();
 
   virtual void Copy(const ARdsSymMatrix& other);
 
@@ -52,7 +53,7 @@ class ARdsSymMatrix: public ARMatrix<ART
   void CreateStructure();
 
   void ThrowError();
-  
+
  public:
 
   bool IsFactored() { return factored; }
@@ -91,11 +92,11 @@ class ARdsSymMatrix: public ARMatrix<ART
 
 template<class ARTYPE>
 inline void ARdsSymMatrix<ARTYPE>::ClearMem()
-{ 
+{
 
   if (factored) {
     delete[] Ainv;
-    delete[] ipiv; 
+    delete[] ipiv;
     Ainv = NULL;
     ipiv = NULL;
   }
@@ -110,9 +111,9 @@ Copy(const ARdsSymMatrix<ARTYPE>& other)
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   uplo      = other.uplo;
   info      = other.info;
@@ -124,11 +125,11 @@ Copy(const ARdsSymMatrix<ARTYPE>& other)
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[(n*n+n)/2];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
+  ipiv = new int[this->n];
 
-  copy((n*n+n)/2, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy((this->n*this->n+this->n)/2, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -141,15 +142,15 @@ void ARdsSymMatrix<ARTYPE>::SubtractAsI(
 
   // Copying A to Ainv.
 
-  ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
+  ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
 
   // Subtracting sigma from diagonal elements.
 
   if (uplo=='L') {
-    for (i=0, j=0; i<n; j+=(n-(i++))) Ainv[j] -= sigma;
+    for (i=0, j=0; i<this->n; j+=(this->n-(i++))) Ainv[j] -= sigma;
   }
   else {
-    for (i=0, j=0; i<n; j+=(++i)) Ainv[j] -= sigma;
+    for (i=0, j=0; i<this->n; j+=(++i)) Ainv[j] -= sigma;
   }
 
 } // SubtractAsI.
@@ -160,8 +161,8 @@ inline void ARdsSymMatrix<ARTYPE>::Creat
 {
 
   ClearMem();
-  Ainv = new ARTYPE[(n*n+n)/2];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -188,7 +189,7 @@ void ARdsSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorA");
   }
 
@@ -198,11 +199,11 @@ void ARdsSymMatrix<ARTYPE>::FactorA()
 
   // Copying A to Ainv;
 
-  ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
+  ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
 
   // Decomposing A.
 
-  sptrf(&uplo, n, Ainv, ipiv, info);
+  sptrf(&uplo, this->n, Ainv, ipiv, info);
 
   // Handling errors.
 
@@ -219,7 +220,7 @@ void ARdsSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorAsI");
   }
 
@@ -233,7 +234,7 @@ void ARdsSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  sptrf(&uplo, n, Ainv, ipiv, info);
+  sptrf(&uplo, this->n, Ainv, ipiv, info);
 
   // Handling errors.
 
@@ -254,30 +255,30 @@ void ARdsSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::MultMv");
   }
 
-  // Determining w = M.v (unfortunately, the BLAS does not 
+  // Determining w = M.v (unfortunately, the BLAS does not
   // have a routine that works with packed matrices).
 
-  for (i=0; i<n; i++) w[i] = zero;
+  for (i=0; i<this->n; i++) w[i] = zero;
 
   if (uplo=='L') {
- 
-    for (i=0, j=0; i<n; j+=(n-(i++))) {
-      w[i] += dot(n-i, &A[j], 1, &v[i], 1);
-      axpy(n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
+
+    for (i=0, j=0; i<this->n; j+=(this->n-(i++))) {
+      w[i] += dot(this->n-i, &A[j], 1, &v[i], 1);
+      axpy(this->n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
     }
- 
-  }  
+
+  }
   else { // uplo = 'U'
 
-    for (i=0, j=0; i<n; j+=(++i)) {
+    for (i=0, j=0; i<this->n; j+=(++i)) {
       w[i] += dot(i+1, &A[j], 1, v, 1);
       axpy(i, v[i], &A[j], 1, w, 1);
     }
-   
+
   }
 
 } // MultMv.
@@ -296,11 +297,11 @@ void ARdsSymMatrix<ARTYPE>::MultInvv(ART
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  sptrs(&uplo, n, 1, Ainv, ipiv, w, n, info);
+  sptrs(&uplo, this->n, 1, Ainv, ipiv, w, this->n, info);
 
   // Handling errors.
 
@@ -316,14 +317,14 @@ DefineMatrix(int np, ARTYPE* Ap, char up
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   uplo      = uplop;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
-  info      = 0; 
+  info      = 0;
 
 } // DefineMatrix.
 
@@ -334,7 +335,7 @@ ARdsSymMatrix(int np, ARTYPE* Ap, char u
 {
 
   factored = false;
-  DefineMatrix(np, Ap, uplop);
+  this->DefineMatrix(np, Ap, uplop);
 
 } // Long constructor.
 
@@ -345,7 +346,7 @@ operator=(const ARdsSymMatrix<ARTYPE>& o
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ardsnsym.h /usr/local/include/arpack++/ardsnsym.h
--- arpack++/include/ardsnsym.h	2000-02-21 04:44:18.000000000 +0530
+++ /usr/local/include/arpack++/ardsnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDSNSym.h.
-   Arpack++ class ARluNonSymStdEig definition
+   Arpack++ class ARdsNonSymStdEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,14 +18,15 @@
 #ifndef ARDSNSYM_H
 #define ARDSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "ardnsmat.h"
 
 
 template<class ARFLOAT>
-class ARluNonSymStdEig:
+class ARdsNonSymStdEig:
   public virtual ARNonSymStdEig<ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> > {
 
  public:
@@ -42,116 +43,116 @@ class ARluNonSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluNonSymStdEig() { }
+  ARdsNonSymStdEig() { }
   // Short constructor.
 
-  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   char* whichp = "LM", int ncvp = 0,
+  ARdsNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARdsNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }
+  ARdsNonSymStdEig(const ARdsNonSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymStdEig() { }
+  virtual ~ARdsNonSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluNonSymStdEig& operator=(const ARluNonSymStdEig& other);
+  ARdsNonSymStdEig& operator=(const ARdsNonSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymStdEig.
+}; // class ARdsNonSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymStdEig member functions definition.                            //
+// ARdsNonSymStdEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::
+inline void ARdsNonSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARdsNonSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARdsNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+inline ARdsNonSymStdEig<ARFLOAT>::
+ARdsNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, 
-                   &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
-                   whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
+                         &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
+                         whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARdsNonSymStdEig<ARFLOAT>::
+ARdsNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
-                   &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
-                   whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->DefineParameters(A.ncols(), nevp, &A,
+                         &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
+                         whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluNonSymStdEig<ARFLOAT>& ARluNonSymStdEig<ARFLOAT>::
-operator=(const ARluNonSymStdEig<ARFLOAT>& other)
+ARdsNonSymStdEig<ARFLOAT>& ARdsNonSymStdEig<ARFLOAT>::
+operator=(const ARdsNonSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -160,4 +161,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARDSNSYM_H
-
diff -rupN arpack++/include/ardspen.h /usr/local/include/arpack++/ardspen.h
--- arpack++/include/ardspen.h	2000-02-21 04:27:18.000000000 +0530
+++ /usr/local/include/arpack++/ardspen.h	2016-11-17 18:22:42.132889211 +0530
@@ -106,7 +106,7 @@ void ARdsSymPencil<ARTYPE>::SubtractAsB(
 
   if (A->uplo == B->uplo) {
 
-    axpy(sizeA, -sigma, B->A, 1, AsB.Ainv, 1); 
+    axpy(sizeA, -sigma, B->A, 1, AsB.Ainv, 1);
 
   }
   else if (A->uplo == 'L') { // B->uplo == 'U'
@@ -129,7 +129,7 @@ void ARdsSymPencil<ARTYPE>::SubtractAsB(
     }
 
   }
-    
+
 } // SubtractAsB (ARTYPE shift).
 
 
@@ -162,7 +162,7 @@ void ARdsSymPencil<ARTYPE>::FactorAsB(AR
 
   // Reserving memory for some vectors used in matrix decomposition.
 
-  AsB.CreateStructure(); 
+  AsB.CreateStructure();
 
   // Subtracting sigma*B from A and storing the result on AsB.
 
@@ -216,7 +216,7 @@ ARdsSymPencil(ARdsSymMatrix<ARTYPE>& Ap,
 {
 
   AsB.factored  = false;
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/ardssym.h /usr/local/include/arpack++/ardssym.h
--- arpack++/include/ardssym.h	2000-02-21 04:39:40.000000000 +0530
+++ /usr/local/include/arpack++/ardssym.h	2016-11-17 18:22:42.132889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARDSSym.h.
-   Arpack++ class ARluSymStdEig definition
+   Arpack++ class ARdsSymStdEig definition
    (dense matrix version).
 
    ARPACK Authors
@@ -18,14 +18,15 @@
 #ifndef ARDSSYM_H
 #define ARDSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "ardsmat.h"
 
 
 template<class ARFLOAT>
-class ARluSymStdEig:
+class ARdsSymStdEig:
   public virtual ARSymStdEig<ARFLOAT, ARdsSymMatrix<ARFLOAT> > {
 
  public:
@@ -42,112 +43,112 @@ class ARluSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluSymStdEig() { }
+  ARdsSymStdEig() { }
   // Short constructor.
 
-  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-                char* whichp = "LM", int ncvp = 0,
+  ARdsSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+                const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-                ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARdsSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+                ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }
+  ARdsSymStdEig(const ARdsSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymStdEig() { }
+  virtual ~ARdsSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluSymStdEig& operator=(const ARluSymStdEig& other);
+  ARdsSymStdEig& operator=(const ARdsSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluSymStdEig.
+}; // class ARdsSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymStdEig member functions definition.                               //
+// ARdsSymStdEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::
+inline void ARdsSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARdsSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARdsSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-              char* whichp, int ncvp, ARFLOAT tolp,
+inline ARdsSymStdEig<ARFLOAT>::
+ARdsSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultMv,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
-              ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARdsSymStdEig<ARFLOAT>::
+ARdsSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
+              ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultInvv,
+  this->DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluSymStdEig<ARFLOAT>& ARluSymStdEig<ARFLOAT>::
-operator=(const ARluSymStdEig<ARFLOAT>& other)
+ARdsSymStdEig<ARFLOAT>& ARdsSymStdEig<ARFLOAT>::
+operator=(const ARdsSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -156,4 +157,3 @@ operator=(const ARluSymStdEig<ARFLOAT>&
 
 
 #endif // ARDSSYM_H
-
diff -rupN arpack++/include/arerror.h /usr/local/include/arpack++/arerror.h
--- arpack++/include/arerror.h	2000-03-02 00:29:37.000000000 +0530
+++ /usr/local/include/arpack++/arerror.h	2016-11-17 18:22:42.132889211 +0530
@@ -29,9 +29,10 @@
 #ifndef ARERROR_H
 #define ARERROR_H
 
+#include <iostream>
+#include <cstdlib>
+
 #include "arch.h"
-#include <iostream.h>
-#include <stdlib.h>
 
 class ArpackError {
 
@@ -98,7 +99,7 @@ class ArpackError {
 
     // Errors in matrix files.
 
-    CANNOT_OPEN_FILE    = -551, 
+    CANNOT_OPEN_FILE    = -551,
     WRONG_MATRIX_TYPE   = -552,
     WRONG_DATA_TYPE     = -553,
     RHS_IGNORED         = -554,
@@ -124,25 +125,29 @@ class ArpackError {
 
  private:
 
-  static ErrorCode code;
+  static ErrorCode & code()
+  {
+    static ErrorCode c;
+    return c;
+  }
 
   static void Print(const char* where, const char* message);
   // Writes error messages on cerr stream.
 
  public:
 
-  static void Set(ErrorCode error, char* where="AREigenProblem");
+  static void Set(ErrorCode error, const char* where="AREigenProblem");
   // Set error code and write error messages.
 
-  static int Status() { return (int) code; }
+  static int Status() { return (int) code(); }
   // Returns current value of error code.
 
-  ArpackError(ErrorCode error, char* where="AREigenProblem") {
+  ArpackError(ErrorCode error, const char* where="AREigenProblem") {
     Set(error,where);
   }
   // Constructor that set error code.
 
-  ArpackError() { code = NO_ERRORS; };
+  ArpackError() { code() = NO_ERRORS; };
   // Constructor that does nothing.
 
 };
@@ -151,17 +156,17 @@ inline void ArpackError::Print(const cha
 {
 
 #ifndef ARPACK_SILENT_MODE
-  cerr << "Arpack error in " << where << "." << endl;
-  cerr << "-> " << message << "." << endl;
+  std::cerr << "Arpack error in " << where << "." << std::endl;
+  std::cerr << "-> " << message << "." << std::endl;
 #endif
 
 } // Print
 
-void ArpackError::Set(ErrorCode error, char* where)
+inline void ArpackError::Set(ErrorCode error, const char* where)
 {
 
-  code = error;
-  switch (code) {
+  code() = error;
+  switch (code()) {
   case NO_ERRORS          :
     return;
   case NOT_IMPLEMENTED    :
@@ -328,7 +333,4 @@ void ArpackError::Set(ErrorCode error, c
 
 } // Set.
 
-ArpackError::ErrorCode ArpackError::code = NO_ERRORS;
-// "code" initialization.
-
 #endif // ARERROR_H
diff -rupN arpack++/include/argcomp.h /usr/local/include/arpack++/argcomp.h
--- arpack++/include/argcomp.h	2000-02-21 05:19:24.000000000 +0530
+++ /usr/local/include/arpack++/argcomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARGCOMP_H
 #define ARGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "argeig.h"
@@ -38,7 +39,7 @@ class ARCompGenEig:
                void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                ARFB* objBp,
                void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
-               char* whichp = "LM", int ncvp = 0,
+               const char* whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0,
                arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
@@ -48,7 +49,7 @@ class ARCompGenEig:
                ARFB* objBp,
                void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                arcomplex<ARFLOAT> sigmap,
-               char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+               const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -78,13 +79,13 @@ ARCompGenEig(int np, int nevp, ARFOP* ob
              void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
              ARFB* objBp,
              void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
-             char* whichp, int ncvp, ARFLOAT tolp,
+             const char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -96,13 +97,13 @@ ARCompGenEig(int np, int nevp, ARFOP* ob
              void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
              ARFB* objBp,
              void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
-             arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+             arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
@@ -114,7 +115,7 @@ operator=(const ARCompGenEig<ARFLOAT, AR
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -123,4 +124,3 @@ operator=(const ARCompGenEig<ARFLOAT, AR
 
 
 #endif // ARGCOMP_H
-
diff -rupN arpack++/include/argeig.h /usr/local/include/arpack++/argeig.h
--- arpack++/include/argeig.h	2000-02-21 05:09:06.000000000 +0530
+++ /usr/local/include/arpack++/argeig.h	2016-11-17 18:22:42.132889211 +0530
@@ -19,7 +19,8 @@
 #ifndef ARGEIG_H
 #define ARGEIG_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "arrgeig.h"
@@ -62,8 +63,8 @@ class ARGenEig:
  // d.1) Function that stores user defined parameters.
 
   virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
-                                TypeOPx MultOPxp, ARFB* objBp, 
-                                TypeBx MultBxp, char* whichp="LM", 
+                                TypeOPx MultOPxp, ARFB* objBp,
+                                TypeBx MultBxp, const char* whichp="LM",
                                 int ncvp=0, ARFLOAT tolp=0.0,
                                 int maxitp=0, ARTYPE* residp=NULL,
                                 bool ishiftp=true);
@@ -122,8 +123,8 @@ template<class ARFLOAT, class ARTYPE, cl
 void ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::
 DefineParameters(int np, int nevp, ARFOP* objOPp,
                  void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), ARFB* objBp,
-                 void (ARFB::* MultBxp)(ARTYPE[], ARTYPE[]), char* whichp,
-                 int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
+                 void (ARFB::* MultBxp)(ARTYPE[], ARTYPE[]), const char* whichp,
+                 int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp,
                  bool ishiftp)
 
 {
@@ -136,7 +137,7 @@ DefineParameters(int np, int nevp, ARFOP
   // Setting common eigen-problem parameters.
 
   ARStdEig<ARFLOAT, ARTYPE, ARFOP>::
-    DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+    this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                      ncvp, tolp, maxitp, residp, ishiftp);
 
 } // DefineParameters.
@@ -149,7 +150,7 @@ ChangeMultBx(ARFB* objBp, void (ARFB::*
 
   objB   = objBp;
   MultBx = MultBxp;
-  Restart();
+  this->Restart();
 
 } // ChangeMultBx.
 
@@ -158,46 +159,46 @@ template<class ARFLOAT, class ARTYPE, cl
 int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::FindArnoldiBasis()
 {
 
-  if (!BasisOK) Restart();
+  if (!this->BasisOK) this->Restart();
 
   // Changing to auto shift mode.
 
-  if (!AutoShift) {
+  if (!this->AutoShift) {
     ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-    AutoShift=true;
+    this->AutoShift=true;
   }
 
   // ARPACK main loop.
 
-  while (!BasisOK) {
+  while (!this->BasisOK) {
 
     // Calling Aupp.
 
-    try { TakeStep(); }
+    try { this->TakeStep(); }
     catch (ArpackError) {
       ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
       return 0;
     }
 
-    switch (ido) {
+    switch (this->ido) {
     case -1:
 
       // Performing y <- OP*B*x for the first time when mode != 2.
 
-      if (mode != 2) {
-        ipntr[3] = ipntr[2]+n; // not a clever idea, but...
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
+      if (this->mode != 2) {
+        this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
+        (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
       }
 
     case  1:
 
       // Performing y <- OP*w.
 
-      if (mode == 2) { // w = x if mode = 2.
-        (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      if (this->mode == 2) { // w = x if mode = 2.
+        (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
       }
       else {           // w = B*x otherwise.
-        (objOP->*MultOPx)(&workd[ipntr[3]],&workd[ipntr[2]]);
+        (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[3]],&this->workd[this->ipntr[2]]);
       }
       break;
 
@@ -205,11 +206,11 @@ int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARF
 
       // Performing y <- B*x.
 
-      (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
     }
   }
-  return nconv;
+  return this->nconv;
 
 } // FindArnoldiBasis.
 
@@ -220,7 +221,7 @@ operator=(const ARGenEig<ARFLOAT, ARTYPE
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/argnsym.h /usr/local/include/arpack++/argnsym.h
--- arpack++/include/argnsym.h	2000-02-21 23:51:34.000000000 +0530
+++ /usr/local/include/arpack++/argnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARGNSYM_H
 #define ARGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "blas1c.h"
 #include "lapackc.h"
@@ -68,9 +69,9 @@ class ARNonSymGenEig:
                                   void (ARFOP::* MultOPxp)(ARFLOAT[],ARFLOAT[]));
   // Turns the problem to real shift-and-invert mode with sigmaRp as shift.
 
-  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp, 
-                                   ARFLOAT sigmaIp, ARFOP* objOPp, 
-                                   void (ARFOP::* MultOPxp)(ARFLOAT[],ARFLOAT[]), 
+  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp,
+                                   ARFLOAT sigmaIp, ARFOP* objOPp,
+                                   void (ARFOP::* MultOPxp)(ARFLOAT[],ARFLOAT[]),
                                    ARFB* objAp,
                                    void (ARFB::* MultAxp)(ARFLOAT[],ARFLOAT[]));
   // Turns the problem to complex shift-and-invert mode with shift
@@ -94,20 +95,20 @@ class ARNonSymGenEig:
 
  // d.3) Constructors and destructor.
 
-  ARNonSymGenEig() { part = 'R'; }
+  ARNonSymGenEig() { this->part = 'R'; }
   // Short constructor (Does nothing but calling base classes constructors).
 
   ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                  void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                  ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-                 char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                 const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                  void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                  ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-                 ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
+                 ARFLOAT sigmap, const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                  bool ishiftp = true);
   // Long constructor (real shift and invert mode).
@@ -116,7 +117,7 @@ class ARNonSymGenEig:
                  void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
                  void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                  void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), char partp,
-                 ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
+                 ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
@@ -148,7 +149,7 @@ Copy(const ARNonSymGenEig<ARFLOAT, ARFOP
   ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
   objA   = other.objA;
   MultAx = other.MultAx;
-  part   = other.part;
+  this->part   = other.part;
 
 } // Copy.
 
@@ -161,22 +162,22 @@ void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB
   ARFLOAT  numr, numi, denr, deni;
   ARFLOAT* Ax;
 
-  Ax = new ARFLOAT[n];
+  Ax = new ARFLOAT[this->n];
 
-  for (j=0; j<nconv; j++) {
+  for (j=0; j<this->nconv; j++) {
 
-    ColJ   = j*n;
-    ColJp1 = ColJ+n;
+    ColJ   = j*this->n;
+    ColJp1 = ColJ+this->n;
 
-    if (EigValI[j] == (ARFLOAT)0.0) {
+    if (this->EigValI[j] == (ARFLOAT)0.0) {
 
       // Eigenvalue is real. Computing EigVal = x'(Ax)/x'(Mx).
 
-      (objB->*MultAx)(&EigVec[ColJ], Ax);
-      numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      (objB->*MultBx)(&EigVec[ColJ], Ax);
-      denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      EigValR[j] =  numr / denr;
+      (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
+      numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
+      denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      this->EigValR[j] =  numr / denr;
 
     }
     else {
@@ -185,32 +186,32 @@ void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB
 
       // Computing x'(Ax).
 
-      (objB->*MultAx)(&EigVec[ColJ], Ax);
-      numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      numi = dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      (objB->*MultAx)(&EigVec[ColJp1], Ax);
-      numr = numr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      numi = -numi + dot(n, &EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
+      numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      numi = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      (this->objB->*MultAx)(&this->EigVec[ColJp1], Ax);
+      numr = numr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      numi = -numi + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
 
       // Computing x'(Mx).
 
-      (objB->*MultBx)(&EigVec[ColJ], Ax);
-      denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      deni = dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      (objB->*MultBx)(&EigVec[ColJp1], Ax);
-      denr = denr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      deni = -deni + dot(n, &EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
+      denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      deni = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJp1], Ax);
+      denr = denr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      deni = -deni + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
 
       // Computing the first eigenvalue of the conjugate pair.
 
-      EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
-      EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
+      this->EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
+      this->EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
 
       // Getting the second eigenvalue of the conjugate pair by taking
       // the conjugate of the first.
 
-      EigValR[j+1] = EigValR[j];
-      EigValI[j+1] = -EigValI[j];
+      this->EigValR[j+1] = this->EigValR[j];
+      this->EigValI[j+1] = -this->EigValI[j];
       j++;
 
     }
@@ -228,28 +229,28 @@ SetShiftInvertMode(ARFLOAT sigmaRp, ARFO
                    void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  part    = 'R';
-  objOP   = objOPp;
-  MultOPx = MultOPxp;
-  ChangeShift(sigmaRp);
+  this->part    = 'R';
+  this->objOP   = objOPp;
+  this->MultOPx = MultOPxp;
+  this->ChangeShift(sigmaRp);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT, class ARFOP, class ARFB>
 inline void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::
-SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, 
-                    ARFOP* objOPp, 
+SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
+                    ARFOP* objOPp,
                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                     ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  objOP   = objOPp;
-  MultOPx = MultOPxp;
+  this->objOP   = objOPp;
+  this->MultOPx = MultOPxp;
   objA    = objAp;
   MultAx  = MultAxp;
-  part    = CheckPart(partp);
-  ChangeShift(sigmaRp, sigmaIp);
+  this->part    = this->CheckPart(partp);
+  this->ChangeShift(sigmaRp, sigmaIp);
 
 } // SetComplexShiftMode.
 
@@ -258,9 +259,9 @@ template<class ARFLOAT, class ARFOP, cla
 inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvalues()
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindEigenvalues.
 
@@ -269,9 +270,9 @@ template<class ARFLOAT, class ARFOP, cla
 inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvectors(bool schurp)
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindEigenvectors.
 
@@ -280,9 +281,9 @@ template<class ARFLOAT, class ARFOP, cla
 int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindSchurVectors()
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindSchurVectors.
 
@@ -292,14 +293,14 @@ inline ARNonSymGenEig<ARFLOAT, ARFOP, AR
 ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-               char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+               const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                ARFLOAT* residp, bool ishiftp)
 
 {
 
-  part = 'R';                // Considering mode = 3 in ChangeShift.
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->part = 'R';                // Considering mode = 3 in ChangeShift.
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -310,13 +311,13 @@ inline ARNonSymGenEig<ARFLOAT, ARFOP, AR
 ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-               ARFLOAT sigmap, char* whichp, int ncvp,
+               ARFLOAT sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   SetShiftInvertMode(sigmap, objOPp, MultOPxp);
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 
@@ -330,14 +331,14 @@ ARNonSymGenEig(int np, int nevp, ARFOP*
                ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
                ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
                char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
-               char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+               const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                ARFLOAT* residp, bool ishiftp)
 
 {
 
   SetComplexShiftMode(partp, sigmaRp, sigmaIp, objOPp,
                       MultOPxp, objAp, MultAxp);
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
@@ -349,7 +350,7 @@ operator=(const ARNonSymGenEig<ARFLOAT,
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/argsym.h /usr/local/include/arpack++/argsym.h
--- arpack++/include/argsym.h	2000-02-21 23:52:35.000000000 +0530
+++ /usr/local/include/arpack++/argsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARGSYM_H
 #define ARGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arrgsym.h"
@@ -66,7 +67,7 @@ class ARSymGenEig:
   // Turns problem to buckling mode with shift defined by sigmap.
 
   void SetCayleyMode(ARFLOAT sigmap, ARFOP* objOPp,
-                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), 
+                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                      ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]));
   // Turns problem to Cayley mode with shift defined by sigmap.
 
@@ -79,20 +80,20 @@ class ARSymGenEig:
 
  // d.3) Constructors and destructor.
 
-  ARSymGenEig() { InvertMode = 'S'; }
+  ARSymGenEig() { this->InvertMode = 'S'; }
   // Short constructor that does almost nothing.
 
   ARSymGenEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
               void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-              char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+              const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
               int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARSymGenEig(char invertmodep, int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
               ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-              ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
+              ARFLOAT sigmap, const char* whichp = "LM", int ncvp = 0,
               ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
               bool ishiftp = true);
   // Long constructor (shift-and-invert and buckling mode).
@@ -101,7 +102,7 @@ class ARSymGenEig:
               void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
               void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
               void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), ARFLOAT sigmap,
-              char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+              const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
               int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (cayley mode).
 
@@ -132,7 +133,7 @@ Copy(const ARSymGenEig<ARFLOAT, ARFOP, A
   ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
   objA       = other.objA;
   MultAx     = other.MultAx;
-  InvertMode = other.InvertMode;
+  this->InvertMode = other.InvertMode;
 
 } // Copy.
 
@@ -143,43 +144,43 @@ SetShiftInvertMode(ARFLOAT sigmap, ARFOP
                    void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  InvertMode = 'S';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
-  ChangeShift(sigmap);
+  this->InvertMode = 'S';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
+  this->ChangeShift(sigmap);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT, class ARFOP, class ARFB>
 void ARSymGenEig<ARFLOAT, ARFOP, ARFB>::
-SetBucklingMode(ARFLOAT sigmap, ARFOP* objOPp, 
+SetBucklingMode(ARFLOAT sigmap, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
 
 {
 
-  InvertMode = 'B';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
-  ChangeShift(sigmap);
+  this->InvertMode = 'B';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
+  this->ChangeShift(sigmap);
 
 } // SetBucklingMode.
 
 
 template<class ARFLOAT, class ARFOP, class ARFB>
 void ARSymGenEig<ARFLOAT, ARFOP, ARFB>::
-SetCayleyMode(ARFLOAT sigmap, ARFOP* objOPp, 
-              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp, 
+SetCayleyMode(ARFLOAT sigmap, ARFOP* objOPp,
+              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
               void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]))
 
 {
 
-  InvertMode = 'C';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
+  this->InvertMode = 'C';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
   objA       = objAp;
   MultAx     = MultAxp;
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // SetCayleyMode.
 
@@ -190,64 +191,64 @@ int ARSymGenEig<ARFLOAT, ARFOP, ARFB>::F
 
   ARFLOAT* temp;
 
-  if (mode != 5) {  // Using base function if not in Cayley mode.
+  if (this->mode != 5) {  // Using base function if not in Cayley mode.
     return ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::FindArnoldiBasis();
   }
   else {
 
-    temp = new ARFLOAT[n+1];
+    temp = new ARFLOAT[this->n+1];
 
-    if (!BasisOK) Restart();
+    if (!this->BasisOK) this->Restart();
 
     // Changing to auto shift mode.
 
-    if (!AutoShift) {
+    if (!this->AutoShift) {
       ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-      AutoShift=true;
+      this->AutoShift=true;
     }
 
     // ARPACK main loop.
 
-    while (!BasisOK) {
+    while (!this->BasisOK) {
 
       // Calling Aupp.
 
-      try { TakeStep(); }
+      try { this->TakeStep(); }
       catch (ArpackError) {
         ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
         delete[] temp;
         return 0;
       }
 
-      switch (ido) {
+      switch (this->ido) {
       case -1:
 
         // Performing y <- B*x for the first time.
 
-        ipntr[3] = ipntr[2]+n; // not a clever idea, but...
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
+        this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
+        (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
 
       case  1:
 
         // Performing y <- OP*(A+sigma*B)*x, B*x is already available.
 
-        (objB->*MultAx)(&workd[ipntr[1]], temp);
-        axpy(n, sigmaR, &workd[ipntr[3]], 1, temp, 1);
-        (objOP->*MultOPx)(temp, &workd[ipntr[2]]);
+        (this->objB->*MultAx)(&this->workd[this->ipntr[1]], temp);
+        axpy(this->n, this->sigmaR, &this->workd[this->ipntr[3]], 1, temp, 1);
+        (this->objOP->*(this->MultOPx))(temp, &this->workd[this->ipntr[2]]);
         break;
 
       case  2:
 
         // Performing y <- B*x.
 
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+        (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
       }
     }
 
     delete[] temp;
-   
-    return nconv;
+
+    return this->nconv;
   }
 
 } // FindArnoldiBasis.
@@ -258,14 +259,14 @@ inline ARSymGenEig<ARFLOAT, ARFOP, ARFB>
 ARSymGenEig(int np, int nevp, ARFOP* objOPp,
             void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
             ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-            char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+            const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
             ARFLOAT* residp, bool ishiftp)
 
 {
 
-  InvertMode = 'S';   
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->InvertMode = 'S';
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -276,14 +277,14 @@ inline ARSymGenEig<ARFLOAT, ARFOP, ARFB>
 ARSymGenEig(char InvertModep, int np, int nevp, ARFOP* objOPp,
             void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
             ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-            ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+            ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
             int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  this->InvertMode = this->CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift-and-invert and buckling mode).
@@ -295,13 +296,13 @@ ARSymGenEig(int np, int nevp, ARFOP* obj
             void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
             ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
             ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
-            ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+            ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
             int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  SetCayleyMode(sigmap, objOPp, MultOPx, objAp, MultAxp);
-  DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
+  SetCayleyMode(sigmap, objOPp, this->MultOPx, objAp, MultAxp);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (cayley mode).
@@ -313,7 +314,7 @@ operator=(const ARSymGenEig<ARFLOAT, ARF
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arhbmat.h /usr/local/include/arpack++/arhbmat.h
--- arpack++/include/arhbmat.h	2000-02-22 00:07:14.000000000 +0530
+++ /usr/local/include/arpack++/arhbmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,10 +20,11 @@
 #ifndef ARHBMAT_H
 #define ARHBMAT_H
 
-#include <stddef.h>
-#include <fstream.h>
-#include <stdlib.h>
-#include <string.h>
+#include <cstddef>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+
 #include "arch.h"
 #include "arerror.h"
 
@@ -46,17 +47,17 @@ class ARhbMatrix {
 
   void ConvertDouble(char* num);
 
-  bool ReadEntry(ifstream& file, int nval, int fval, int& j, double& val);
+  bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval, int& j, float& val);
+  bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval,
+  bool ReadEntry(std::ifstream& file, int nval, int fval,
                  int& j, arcomplex<double>& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval,
+  bool ReadEntry(std::ifstream& file, int nval, int fval,
                  int& j, arcomplex<float>& val);
 
-  void ReadFormat(ifstream& file, int& n, int& fmt);
+  void ReadFormat(std::ifstream& file, int& n, int& fmt);
 
  public:
 
@@ -131,7 +132,7 @@ inline void ARhbMatrix<ARINT, ARTYPE>::C
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval, int& j, double& val)
+ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val)
 {
 
   char num[81];
@@ -152,7 +153,7 @@ ReadEntry(ifstream& file, int nval, int
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval, int& j, float& val)
+ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val)
 {
 
   double dval;
@@ -167,7 +168,7 @@ ReadEntry(ifstream& file, int nval, int
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval,
+ReadEntry(std::ifstream& file, int nval, int fval,
           int& j, arcomplex<double>& val)
 {
 
@@ -196,7 +197,7 @@ ReadEntry(ifstream& file, int nval, int
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval,
+ReadEntry(std::ifstream& file, int nval, int fval,
           int& j, arcomplex<float>& val)
 {
 
@@ -227,7 +228,7 @@ ReadEntry(ifstream& file, int nval, int
 
 
 template<class ARINT, class ARTYPE>
-void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(ifstream& file, int& n, int& fmt)
+void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(std::ifstream& file, int& n, int& fmt)
 {
 
   char c;
@@ -267,7 +268,7 @@ void ARhbMatrix<ARINT, ARTYPE>::Define(c
   // Opening file.
 
   datafile = filename;
-  ifstream file(datafile);
+  std::ifstream file(datafile);
   
   if (!file) {
     throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARhbMatrix");
diff -rupN arpack++/include/arlgcomp.h /usr/local/include/arpack++/arlgcomp.h
--- arpack++/include/arlgcomp.h	2000-02-21 06:01:04.000000000 +0530
+++ /usr/local/include/arpack++/arlgcomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -18,7 +18,8 @@
 #ifndef ARLGCOMP_H
 #define ARLGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlnsmat.h"
 #include "arlnspen.h"
@@ -65,14 +66,14 @@ class ARluCompGenEig:
 
   ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 char* whichp = "LM", int ncvp = 0,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -103,9 +104,9 @@ Copy(const ARluCompGenEig<ARFLOAT>& othe
   ARCompGenEig<ARFLOAT, ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  if (mode > 2) objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
 
 } // Copy.
 
@@ -114,7 +115,7 @@ template<class ARFLOAT>
 inline void ARluCompGenEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -148,17 +149,17 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 template<class ARFLOAT>
 inline ARluCompGenEig<ARFLOAT>::
 ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
+               ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp,
                arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
-                   &Pencil, 
+                   &Pencil,
                    &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -169,16 +170,16 @@ template<class ARFLOAT>
 inline ARluCompGenEig<ARFLOAT>::
 ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
-                   &Pencil, 
+                   &Pencil,
                    &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
   SetShiftInvertMode(sigmap);
@@ -192,7 +193,7 @@ operator=(const ARluCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arlgnsym.h /usr/local/include/arpack++/arlgnsym.h
--- arpack++/include/arlgnsym.h	2000-02-21 05:55:52.000000000 +0530
+++ /usr/local/include/arpack++/arlgnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -18,7 +18,8 @@
 #ifndef ARLGNSYM_H
 #define ARLGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlnsmat.h"
 #include "arlnspen.h"
@@ -64,21 +65,21 @@ class ARluNonSymGenEig:
   // Short constructor.
 
   ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
+                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
-                   char* whichp = "LM", int ncvp = 0,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (real shift and invert mode).
 
   ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
-                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
+                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
@@ -110,15 +111,15 @@ Copy(const ARluNonSymGenEig<ARFLOAT>& ot
   ARNonSymGenEig<ARFLOAT, ARluNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARluNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
-  if (mode > 2) {
-    if (sigmaI == 0.0) {
-      objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
+  if (this->mode > 2) {
+    if (this->sigmaI == 0.0) {
+      this->objOP->FactorAsB(this->sigmaR);
     }
     else {
-      objOP->FactorAsB(sigmaR, sigmaI, part);
+      this->objOP->FactorAsB(this->sigmaR, this->sigmaI, this->part);
     }
   }
 
@@ -131,10 +132,10 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -170,8 +171,8 @@ SetComplexShiftMode(char partp, ARFLOAT
 
   ARNonSymGenEig<ARFLOAT, ARluNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARluNonSymPencil<ARFLOAT, ARFLOAT> >::
-    SetComplexShiftMode(partp, sigmaRp, sigmaIp, &Pencil, 
-                        &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, 
+    SetComplexShiftMode(partp, sigmaRp, sigmaIp, &Pencil,
+                        &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv,
                         &Pencil, &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultAv);
 
 } // SetComplexShiftMode.
@@ -180,14 +181,14 @@ SetComplexShiftMode(char partp, ARFLOAT
 template<class ARFLOAT>
 inline ARluNonSymGenEig<ARFLOAT>::
 ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
+                 ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -199,13 +200,13 @@ template<class ARFLOAT>
 inline ARluNonSymGenEig<ARFLOAT>::
 ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                  ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -217,15 +218,15 @@ ARluNonSymGenEig(int nevp, ARluNonSymMat
 template<class ARFLOAT>
 inline ARluNonSymGenEig<ARFLOAT>::
 ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
+                 ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B,
                  char partp, ARFLOAT sigmaRp,
-                 ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
+                 ARFLOAT sigmaIp, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -240,7 +241,7 @@ operator=(const ARluNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arlgsym.h /usr/local/include/arpack++/arlgsym.h
--- arpack++/include/arlgsym.h	2000-02-21 05:50:30.000000000 +0530
+++ /usr/local/include/arpack++/arlgsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -19,7 +19,8 @@
 #ifndef ARLGSYM_H
 #define ARLGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlsmat.h"
 #include "arlspen.h"
@@ -67,13 +68,13 @@ class ARluSymGenEig:
   // Short constructor.
 
   ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-                ARluSymMatrix<ARFLOAT>& B, char* whichp = "LM",
+                ARluSymMatrix<ARFLOAT>& B, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
-                ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM",
+                ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert, buckling and Cayley modes).
@@ -105,10 +106,10 @@ Copy(const ARluSymGenEig<ARFLOAT>& other
   ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>,
               ARluSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
-  if (mode > 2) objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
+  if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
 
 } // Copy.
 
@@ -117,7 +118,7 @@ template<class ARFLOAT>
 inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -173,15 +174,15 @@ SetCayleyMode(ARFLOAT sigmap)
 template<class ARFLOAT>
 inline ARluSymGenEig<ARFLOAT>::
 ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-              ARluSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
+              ARluSymMatrix<ARFLOAT>& B, const char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->InvertMode = 'S';
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -193,22 +194,22 @@ template<class ARFLOAT>
 inline ARluSymGenEig<ARFLOAT>::
 ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
               ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
-              char* whichp, int ncvp, ARFLOAT tolp,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':  // Buckling mode.
     ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
   case 'S':  // Shift and invert mode.
-    ChangeShift(sigmap);
+    this->ChangeShift(sigmap);
     break;
   case 'C':  // Cayley mode.
     SetCayleyMode(sigmap);
@@ -223,7 +224,7 @@ operator=(const ARluSymGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arlnsmat.h /usr/local/include/arpack++/arlnsmat.h
--- arpack++/include/arlnsmat.h	2000-02-22 18:57:32.000000000 +0530
+++ /usr/local/include/arpack++/arlnsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,8 @@
 #ifndef ARLNSMAT_H
 #define ARLNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -101,7 +102,7 @@ class ARluNonSymMatrix: public ARMatrix<
   ARluNonSymMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp,int* pcolp);
   // Long constructor (rectangular matrix).
 
-  ARluNonSymMatrix(char* name, double thresholdp = 0.1, 
+  ARluNonSymMatrix(char* name, double thresholdp = 0.1,
                    int orderp = 1, bool check = true);
   // Long constructor (Harwell-Boeing file).
 
@@ -130,16 +131,16 @@ bool ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
-      if ((irow[j]<0)||(irow[k]>=n)) return false;
+      if ((irow[j]<0)||(irow[k]>=this->n)) return false;
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
     }
@@ -157,28 +158,28 @@ Copy(const ARluNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables.
 
-  defined   = other.defined;
+  this->defined   = other.defined;
   factored  = other.factored;
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying user-defined parameters.
 
   if (other.n == other.m) {
-    DefineMatrix(other.n, other.nnz, other.a, other.irow,
+    this->DefineMatrix(other.n, other.nnz, other.a, other.irow,
                  other.pcol, other.threshold, other.order);
   }
   else {
-    DefineMatrix(other.m, other.n, other.nnz, 
+    this->DefineMatrix(other.m, other.n, other.nnz,
                  other.a, other.irow, other.pcol);
   }
 
-  // Throwing the original factorization away (this procedure 
+  // Throwing the original factorization away (this procedure
   // is really awkward, but it is necessary because there
-  // is no copy function for matrices L and U in the SuperLU 
-  // library and it is not a good idea to do this kind of deep 
+  // is no copy function for matrices L and U in the SuperLU
+  // library and it is not a good idea to do this kind of deep
   // copy here).
 
   if (factored) {
@@ -198,7 +199,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     Destroy_CompCol_Matrix(&U);
     StatFree();
   }
-  if (defined) {
+  if (this->defined) {
     Destroy_SuperMatrix_Store(&A); // delete A.Store;
     delete[] permc;
     delete[] permr;
@@ -231,7 +232,7 @@ SubtractAsI(ARTYPE sigma, NCformat& A, N
   k = 0;
   AsI.colptr[0] = 0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
 
     j = A.colptr[i];
     end = A.colptr[i+1];
@@ -264,7 +265,7 @@ SubtractAsI(ARTYPE sigma, NCformat& A, N
 
   }
 
-  AsI.nnz = AsI.colptr[n];
+  AsI.nnz = AsI.colptr[this->n];
 
 } // SubtractAsI.
 
@@ -281,19 +282,19 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::FactorA");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARluNonSymMatrix::FactorA");
   }
 
   // Deleting previous versions of L and U.
-  
+
   if (factored) {
     Destroy_SuperNode_Matrix(&L);
     Destroy_CompCol_Matrix(&U);
@@ -308,7 +309,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -322,11 +323,11 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   // Permuting columns of A and
   // creating the elimination tree of A'*A.
 
-  sp_preorder("N", &A, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &A, permc, etree, &AC);
 
   // Decomposing A.
 
-  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC and etree.
@@ -342,7 +343,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluNonSymMatrix::FactorA");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluNonSymMatrix::FactorA");
   }
@@ -360,14 +361,14 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARluNonSymMatrix::FactorAsI");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARluNonSymMatrix::FactorAsI");
   }
@@ -385,7 +386,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   NCformat*   AsIstore;
 
   // Deleting previous versions of L and U.
-  
+
   if (factored) {
     Destroy_SuperNode_Matrix(&L);
     Destroy_CompCol_Matrix(&U);
@@ -400,10 +401,10 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Creating a temporary matrix AsI.
 
-  irowi = new int[nnz+n];
-  pcoli = new int[n+1];
-  asi   = new ARTYPE[nnz+n];
-  Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
+  irowi = new int[nnz+this->n];
+  pcoli = new int[this->n+1];
+  asi   = new ARTYPE[nnz+this->n];
+  Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, NC, GE);
 
   // Subtracting sigma*I from A and storing the result on AsI.
 
@@ -413,7 +414,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -427,11 +428,11 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   // Permuting columns of AsI and
   // creating the elimination tree of AsI'*AsI.
 
-  sp_preorder("N", &AsI, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &AsI, permc, etree, &AC);
 
   // Decomposing AsI.
 
-  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC, AsI and etree.
@@ -448,7 +449,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluNonSymMatrix::FactorAsI");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluNonSymMatrix::FactorAsI");
   }
@@ -469,15 +470,15 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = v[i];
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       w[irow[j]] += t*a[j];
@@ -496,13 +497,13 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = (ARTYPE)0;
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       t += v[irow[j]]*a[j];
@@ -517,7 +518,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -531,7 +532,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -545,8 +546,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -567,9 +568,9 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   int         info;
   SuperMatrix B;
 
-  if (&v != &w) copy(n, v, 1, w, 1);
-  Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
-  gstrs("N", &L, &U, permr, permc, &B, &info);
+  if (&v != &w) copy(this->n, v, 1, w, 1);
+  Create_Dense_Matrix(&B, this->n, 1, w, this->n, DN, GE);
+  gstrs(APP_C_STR("N"), &L, &U, permr, permc, &B, &info);
   Destroy_SuperMatrix_Store(&B); // delete B.Store;
 
 } // MultInvv.
@@ -581,13 +582,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
              double thresholdp, int orderp, bool check)
 {
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   threshold = thresholdp;
   order     = orderp;
 
@@ -600,14 +601,14 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Creating SuperMatrix A.
 
-  Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
+  Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, NC, GE);
 
   // Reserving memory for vectors used in matrix decomposition.
 
-  permc = new int[n];
-  permr = new int[n];
+  permc = new int[this->n];
+  permr = new int[this->n];
 
-  defined = true;
+  this->defined = true;
 
 } // DefineMatrix (square).
 
@@ -617,14 +618,14 @@ inline void ARluNonSymMatrix<ARTYPE, ARF
 DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)
 {
 
-  m       = mp;
-  n       = np;
+  this->m       = mp;
+  this->n       = np;
   nnz     = nnzp;
   a       = ap;
   irow    = irowp;
   pcol    = pcolp;
-  pcol[n] = nnz;
-  defined = true;
+  pcol[this->n] = nnz;
+  this->defined = true;
   permc   = NULL;
   permr   = NULL;
 
@@ -633,9 +634,9 @@ DefineMatrix(int mp, int np, int nnzp, A
 
 template<class ARTYPE, class ARFLOAT>
 inline ARluNonSymMatrix<ARTYPE, ARFLOAT>::ARluNonSymMatrix(): ARMatrix<ARTYPE>()
-{ 
+{
 
-  factored = false;  
+  factored = false;
   permc    = NULL;
   permr    = NULL;
 
@@ -650,7 +651,7 @@ ARluNonSymMatrix(int np, int nnzp, ARTYP
 {
 
   factored = false;
-  DefineMatrix(np, nnzp, ap, irowp, pcolp, thresholdp, orderp, check);
+  this->DefineMatrix(np, nnzp, ap, irowp, pcolp, thresholdp, orderp, check);
 
 } // Long constructor (square matrix).
 
@@ -662,7 +663,7 @@ ARluNonSymMatrix(int mp, int np, int nnz
 {
 
   factored = false;
-  DefineMatrix(mp, np, nnzp, ap, irowp, pcolp);
+  this->DefineMatrix(mp, np, nnzp, ap, irowp, pcolp);
 
 } // Long constructor (retangular matrix).
 
@@ -682,11 +683,11 @@ ARluNonSymMatrix(char* file, double thre
   }
 
   if (mat.NCols()==mat.NRows()) {
-    DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
+    this->DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
                  mat.RowInd(), mat.ColPtr(), thresholdp, orderp, check);
   }
-  else {                             
-    DefineMatrix(mat.NRows(), mat.NCols(), mat.NonZeros(),
+  else {
+    this->DefineMatrix(mat.NRows(), mat.NCols(), mat.NonZeros(),
                  (ARTYPE*)mat.Entries(), mat.RowInd(), mat.ColPtr());
   }
 
diff -rupN arpack++/include/arlnspen.h /usr/local/include/arpack++/arlnspen.h
--- arpack++/include/arlnspen.h	2000-02-22 18:48:59.000000000 +0530
+++ /usr/local/include/arpack++/arlnspen.h	2016-11-17 18:22:42.132889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARLNSPEN_H
 #define ARLNSPEN_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "blas1c.h"
@@ -55,7 +56,7 @@ class ARluNonSymPencil
                    int zind[], int& nz);
 #endif
 
-  void SubtractAsB(int n, ARTYPE sigma, NCformat& A, 
+  void SubtractAsB(int n, ARTYPE sigma, NCformat& A,
                    NCformat& B, NCformat& AsB);
 
 #ifdef ARCOMP_H
@@ -85,13 +86,13 @@ class ARluNonSymPencil
 
   void MultInvAsBv(ARFLOAT* v, ARFLOAT* w);
 
-  void DefineMatrices(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  void DefineMatrices(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                       ARluNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
 
   ARluNonSymPencil();
   // Short constructor that does nothing.
 
-  ARluNonSymPencil(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  ARluNonSymPencil(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                    ARluNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
   // Long constructor.
 
@@ -121,10 +122,10 @@ Copy(const ARluNonSymPencil<ARTYPE, ARFL
   A        = other.A;
   B        = other.B;
 
-  // Throwing the original factorization away (this procedure 
+  // Throwing the original factorization away (this procedure
   // is really awkward, but it is necessary because there
-  // is no copy function for matrices L and U in the SuperLU 
-  // library and it is not a good idea to do this kind of deep 
+  // is no copy function for matrices L and U in the SuperLU
+  // library and it is not a good idea to do this kind of deep
   // copy here).
 
   if (factored) {
@@ -420,11 +421,11 @@ void ARluNonSymPencil<ARTYPE, ARFLOAT>::
   // Permuting columns of AsB and
   // creating the elimination tree of AsB'*AsB.
 
-  sp_preorder("N", &AsB, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &AsB, permc, etree, &AC);
 
   // Decomposing AsB.
 
-  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, A->threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC, AsB and etree.
@@ -534,11 +535,11 @@ FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI
   // Permuting columns of AsB and
   // creating the elimination tree of AsB'*AsB.
 
-  sp_preorder("N", &AsB, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &AsB, permc, etree, &AC);
 
   // Decomposing AsB.
 
-  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree, NULL,
+  gstrf(APP_C_STR("N"),&AC, A->threshold, drop_tol, relax, panel_size, etree, NULL,
         0, permr, permc, &L, &U, &info);
 
   // Deleting AC, AsB and etree.
@@ -601,7 +602,7 @@ MultInvAsBv(arcomplex<ARFLOAT>* v, arcom
 
   copy(A->nrows(), v, 1, w, 1);
   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
-  gstrs("N", &L, &U, permr, permc, &RHS, &info);
+  gstrs(APP_C_STR("N"), &L, &U, permr, permc, &RHS, &info);
 
   Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
 
@@ -630,7 +631,7 @@ void ARluNonSymPencil<ARTYPE, ARFLOAT>::
 
     copy(A->nrows(), v, 1, w, 1);
     Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
-    gstrs("N", &L, &U, permr, permc, &RHS, &info);
+    gstrs(APP_C_STR("N"), &L, &U, permr, permc, &RHS, &info);
 
   }
   else {                // shift is complex.
@@ -642,7 +643,7 @@ void ARluNonSymPencil<ARTYPE, ARFLOAT>::
 
     for (i=0; i!=A->ncols(); i++) tv[i] = arcomplex<ARFLOAT>(v[i],0.0);
     Create_Dense_Matrix(&RHS, A->ncols(), 1, tv, A->ncols(), DN, GE);
-    gstrs("N", &L, &U, permr, permc, &RHS, &info);
+    gstrs(APP_C_STR("N"), &L, &U, permr, permc, &RHS, &info);
 
     if (part=='I') {
       for (i=0; i!=A->ncols(); i++) w[i] = imag(tv[i]);
@@ -664,7 +665,7 @@ void ARluNonSymPencil<ARTYPE, ARFLOAT>::
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARluNonSymPencil<ARTYPE, ARFLOAT>::
-DefineMatrices(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+DefineMatrices(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                ARluNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
@@ -684,9 +685,9 @@ DefineMatrices(ARluNonSymMatrix<ARTYPE,
 template<class ARTYPE, class ARFLOAT>
 inline ARluNonSymPencil<ARTYPE, ARFLOAT>::ARluNonSymPencil()
 {
-  
-  factored = false; 
-  part     = 'N'; 
+
+  factored = false;
+  part     = 'N';
   permr    = NULL;
   permc    = NULL;
 
@@ -695,12 +696,12 @@ inline ARluNonSymPencil<ARTYPE, ARFLOAT>
 
 template<class ARTYPE, class ARFLOAT>
 inline ARluNonSymPencil<ARTYPE, ARFLOAT>::
-ARluNonSymPencil(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+ARluNonSymPencil(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                  ARluNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
   factored = false;
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/arlscomp.h /usr/local/include/arpack++/arlscomp.h
--- arpack++/include/arlscomp.h	2000-02-21 05:58:44.000000000 +0530
+++ /usr/local/include/arpack++/arlscomp.h	2016-11-17 18:22:42.132889211 +0530
@@ -18,7 +18,8 @@
 #ifndef ARLSCOMP_H
 #define ARLSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "arlnsmat.h"
@@ -27,7 +28,7 @@
 
 template<class ARFLOAT>
 class ARluCompStdEig:
-  public virtual ARCompStdEig<ARFLOAT, 
+  public virtual ARCompStdEig<ARFLOAT,
                               ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> > {
 
  protected:
@@ -58,13 +59,13 @@ class ARluCompStdEig:
   // Short constructor.
 
   ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-                 char* whichp = "LM", int ncvp = 0,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -94,10 +95,10 @@ inline void ARluCompStdEig<ARFLOAT>::
 Copy(const ARluCompStdEig<ARFLOAT>& other)
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
     Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -106,7 +107,7 @@ template<class ARFLOAT>
 inline void ARluCompStdEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
 {
 
-  objOP->FactorAsI(sigmap);
+  this->objOP->FactorAsI(sigmap);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -116,9 +117,9 @@ template<class ARFLOAT>
 inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP,
                    &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
@@ -129,9 +130,9 @@ inline void ARluCompStdEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -140,13 +141,13 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 template<class ARFLOAT>
 inline ARluCompStdEig<ARFLOAT>::
 ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               char* whichp, int ncvp, ARFLOAT tolp,
+               const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -156,16 +157,16 @@ ARluCompStdEig(int nevp, ARluNonSymMatri
 template<class ARFLOAT>
 inline ARluCompStdEig<ARFLOAT>::
 ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A,
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
@@ -176,7 +177,7 @@ operator=(const ARluCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arlsmat.h /usr/local/include/arpack++/arlsmat.h
--- arpack++/include/arlsmat.h	2000-02-22 18:49:46.000000000 +0530
+++ /usr/local/include/arpack++/arlsmat.h	2016-11-17 18:22:42.132889211 +0530
@@ -20,7 +20,7 @@
 #ifndef ARLSMAT_H
 #define ARLSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -117,12 +117,12 @@ bool ARluSymMatrix<ARTYPE>::DataOK()
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
@@ -130,12 +130,12 @@ bool ARluSymMatrix<ARTYPE>::DataOK()
         if ((irow[j]<0)||(irow[k]>i)) return false;
       }
       else { // uplo == 'L'.
-        if ((irow[j]<i)||(irow[k]>=n)) return false;
+        if ((irow[j]<i)||(irow[k]>=this->n)) return false;
       }
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
     }
-  }   
+  }
 
   return true;
 
@@ -148,22 +148,22 @@ inline void ARluSymMatrix<ARTYPE>::Copy(
 
   // Copying very fundamental variables.
 
-  defined   = other.defined;
+  this->defined   = other.defined;
   factored  = other.factored;
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying user-defined parameters.
 
-  DefineMatrix(other.n, other.nnz, other.a, other.irow, other.pcol,
+  this->DefineMatrix(other.n, other.nnz, other.a, other.irow, other.pcol,
                other.uplo, other.threshold, other.order);
 
-  // Throwing the original factorization away (this procedure 
+  // Throwing the original factorization away (this procedure
   // is really awkward, but it is necessary because there
-  // is no copy function for matrices L and U in the SuperLU 
-  // library and it is not a good idea to do this kind of deep 
+  // is no copy function for matrices L and U in the SuperLU
+  // library and it is not a good idea to do this kind of deep
   // copy here).
 
   if (factored) {
@@ -183,7 +183,7 @@ void ARluSymMatrix<ARTYPE>::ClearMem()
     Destroy_CompCol_Matrix(&U);
     StatFree();
   }
-  if (defined) {
+  if (this->defined) {
     Destroy_SuperMatrix_Store(&A); // delete A.Store;
     delete[] permc;
     delete[] permr;
@@ -223,13 +223,13 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
 
   // Filling colE with zeros.
 
-  for (i=0; i<=n; i++) colE[i] = 0;
+  for (i=0; i<=this->n; i++) colE[i] = 0;
 
   // Counting the elements in each column of A.
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = colA[i+1];
       if ((k!=colA[i])&&(indA[k-1]==i)) {
         k--;
@@ -237,13 +237,13 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
       else {
         if (subtract) colE[i]++;
       }
-      for (j=colA[i]; j<k; j++) colE[indA[j]]++;        
+      for (j=colA[i]; j<k; j++) colE[indA[j]]++;
     }
 
   }
   else { // uplo == 'L'
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = colA[i];
       if ((k!=colA[i+1])&&(indA[k]==i)) {
         k++;
@@ -251,28 +251,28 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
       else {
         if (subtract) colE[i]++;
       }
-      for (j=k; j<colA[i+1]; j++) colE[indA[j]]++;        
+      for (j=k; j<colA[i+1]; j++) colE[indA[j]]++;
     }
 
-  }  
+  }
 
   // Summing up colE elements.
 
-  for (i=0; i<n; i++) colE[i+1]+=colE[i];
+  for (i=0; i<this->n; i++) colE[i+1]+=colE[i];
 
   // Adding colA to colE.
 
-  for (i=n; i>0; i--) colE[i] = colE[i-1]+colA[i];
-  colE[0] = colA[0];    
+  for (i=this->n; i>0; i--) colE[i] = colE[i-1]+colA[i];
+  colE[0] = colA[0];
 
   // Expanding A.
 
   if (uplo == 'U') {
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       for (j=colA[i]; j<(colA[i+1]-1); j++) {
         indE[colE[i]] = indA[j];
-        indE[colE[indA[j]]] = i; 
+        indE[colE[indA[j]]] = i;
         valE[colE[i]++] = valA[j];
         valE[colE[indA[j]]++] = valA[j];
       }
@@ -296,7 +296,7 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
   }
   else { // uplo  == 'L'
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       k=colA[i];
       if ((k!=colA[i+1])&&(indA[k]==i)) {
         indE[colE[i]] = i;
@@ -316,7 +316,7 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
       }
       for (j=k; j<colA[i+1]; j++) {
         indE[colE[i]] = indA[j];
-        indE[colE[indA[j]]] = i; 
+        indE[colE[indA[j]]] = i;
         valE[colE[i]++] = valA[j];
         valE[colE[indA[j]]++] = valA[j];
       }
@@ -326,12 +326,12 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
 
   // Adjusting index.
 
-  for (i=n; i>0; i--) {
+  for (i=this->n; i>0; i--) {
     colE[i] = colE[i-1];
-  } 
+  }
   colE[0] = 0;
 
-  Aexp.nnz = colE[n];
+  Aexp.nnz = colE[this->n];
 
 } // ExpandA.
 
@@ -342,7 +342,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorA");
   }
 
@@ -359,7 +359,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
   NCformat*   Aexpstore;
 
   // Deleting previous versions of L and U.
-  
+
   if (factored) {
     Destroy_SuperNode_Matrix(&L);
     Destroy_CompCol_Matrix(&U);
@@ -375,9 +375,9 @@ void ARluSymMatrix<ARTYPE>::FactorA()
   // Creating a temporary matrix Aexp.
 
   irowi = new int[nnz*2];
-  pcoli = new int[n+1];
+  pcoli = new int[this->n+1];
   aexp  = new ARTYPE[nnz*2];
-  Create_CompCol_Matrix(&Aexp, n,  n, nnz, aexp, irowi, pcoli, NC, GE);
+  Create_CompCol_Matrix(&Aexp, this->n,  this->n, nnz, aexp, irowi, pcoli, NC, GE);
 
   // Expanding A.
 
@@ -387,7 +387,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -400,11 +400,11 @@ void ARluSymMatrix<ARTYPE>::FactorA()
 
   // Permuting columns of A and creating the elimination tree.
 
-  sp_preorder("N", &Aexp, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &Aexp, permc, etree, &AC);
 
   // Decomposing A.
 
-  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC, Aexp and etree.
@@ -421,7 +421,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluSymMatrix::FactorA");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluSymMatrix::FactorA");
   }
@@ -439,7 +439,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorAsI");
   }
 
@@ -456,7 +456,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
   NCformat*   AsIstore;
 
   // Deleting previous versions of L and U.
-  
+
   if (factored) {
     Destroy_SuperNode_Matrix(&L);
     Destroy_CompCol_Matrix(&U);
@@ -471,10 +471,10 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Creating a temporary matrix AsI.
 
-  irowi = new int[nnz*2+n];
-  pcoli = new int[n+1];
-  asi   = new ARTYPE[nnz*2+n];
-  Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
+  irowi = new int[nnz*2+this->n];
+  pcoli = new int[this->n+1];
+  asi   = new ARTYPE[nnz*2+this->n];
+  Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, NC, GE);
 
   // Subtracting sigma*I from A and storing the result on AsI.
 
@@ -484,7 +484,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -497,11 +497,11 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Permuting columns of AsI and creating the elimination tree.
 
-  sp_preorder("N", &AsI, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &AsI, permc, etree, &AC);
 
   // Decomposing AsI.
 
-  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC, AsI and etree.
@@ -518,7 +518,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluSymMatrix::FactorAsI");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluSymMatrix::FactorAsI");
   }
@@ -539,17 +539,17 @@ void ARluSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
@@ -565,7 +565,7 @@ void ARluSymMatrix<ARTYPE>::MultMv(ARTYP
   }
   else {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
@@ -599,9 +599,9 @@ void ARluSymMatrix<ARTYPE>::MultInvv(ART
   int         info;
   SuperMatrix B;
 
-  if (&v != &w) copy(n, v, 1, w, 1);
-  Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
-  gstrs("N", &L, &U, permr, permc, &B, &info);
+  if (&v != &w) copy(this->n, v, 1, w, 1);
+  Create_Dense_Matrix(&B, this->n, 1, w, this->n, DN, GE);
+  gstrs(APP_C_STR("N"), &L, &U, permr, permc, &B, &info);
   Destroy_SuperMatrix_Store(&B); // delete B.Store;
 
 } // MultInvv.
@@ -613,13 +613,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
              char uplop, double thresholdp, int orderp, bool check)
 {
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   uplo      = uplop;
   threshold = thresholdp;
   order     = orderp;
@@ -633,14 +633,14 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Creating SuperMatrix A.
 
-  Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
+  Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, NC, GE);
 
   // Reserving memory for vectors used in matrix decomposition.
 
-  permc = new int[n];
-  permr = new int[n];
+  permc = new int[this->n];
+  permr = new int[this->n];
 
-  defined = true;
+  this->defined = true;
 
 } // DefineMatrix.
 
@@ -652,7 +652,7 @@ inline ARluSymMatrix<ARTYPE>::ARluSymMat
   factored = false;
   permc    = NULL;
   permr    = NULL;
- 
+
 } // Short constructor.
 
 
@@ -664,7 +664,7 @@ ARluSymMatrix(int np, int nnzp, ARTYPE*
 {
 
   factored = false;
-  DefineMatrix(np, nnzp, ap, irowp, pcolp, uplop, thresholdp, orderp, check);
+  this->DefineMatrix(np, nnzp, ap, irowp, pcolp, uplop, thresholdp, orderp, check);
 
 } // Long constructor.
 
@@ -685,7 +685,7 @@ ARluSymMatrix(char* file, double thresho
 
   if ((mat.NCols() == mat.NRows()) && (mat.IsSymmetric())) {
 
-    DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
+    this->DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
                  mat.RowInd(), mat.ColPtr(), 'L', thresholdp, orderp, check);
   }
   else {
diff -rupN arpack++/include/arlsnsym.h /usr/local/include/arpack++/arlsnsym.h
--- arpack++/include/arlsnsym.h	2000-02-21 05:52:42.000000000 +0530
+++ /usr/local/include/arpack++/arlsnsym.h	2016-11-17 18:22:42.132889211 +0530
@@ -18,7 +18,8 @@
 #ifndef ARLSNSYM_H
 #define ARLSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "arlnsmat.h"
@@ -55,13 +56,13 @@ class ARluNonSymStdEig:
   // Short constructor.
 
   ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   char* whichp = "LM", int ncvp = 0,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+                   ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -91,7 +92,7 @@ Copy(const ARluNonSymStdEig<ARFLOAT>& ot
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >:: Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -100,13 +101,13 @@ template<class ARFLOAT>
 inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -116,7 +117,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -126,7 +127,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -135,13 +136,13 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 template<class ARFLOAT>
 inline ARluNonSymStdEig<ARFLOAT>::
 ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -151,15 +152,15 @@ ARluNonSymStdEig(int nevp, ARluNonSymMat
 template<class ARFLOAT>
 inline ARluNonSymStdEig<ARFLOAT>::
 ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+                 ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
@@ -170,7 +171,7 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arlspen.h /usr/local/include/arpack++/arlspen.h
--- arpack++/include/arlspen.h	2000-02-22 18:50:33.000000000 +0530
+++ /usr/local/include/arpack++/arlspen.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARLSPEN_H
 #define ARLSPEN_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "blas1c.h"
@@ -52,7 +53,7 @@ class ARluSymPencil
 
   void ExpandAsB(int n, NCformat& AsB);
 
-  void SubtractAsB(int n, ARTYPE sigma, NCformat& A, 
+  void SubtractAsB(int n, ARTYPE sigma, NCformat& A,
                    NCformat& B, NCformat& AsB);
 
  public:
@@ -104,10 +105,10 @@ Copy(const ARluSymPencil<ARTYPE>& other)
   A        = other.A;
   B        = other.B;
 
-  // Throwing the original factorization away (this procedure 
+  // Throwing the original factorization away (this procedure
   // is really awkward, but it is necessary because there
-  // is no copy function for matrices L and U in the SuperLU 
-  // library and it is not a good idea to do this kind of deep 
+  // is no copy function for matrices L and U in the SuperLU
+  // library and it is not a good idea to do this kind of deep
   // copy here).
 
   if (factored) {
@@ -198,7 +199,7 @@ void ARluSymPencil<ARTYPE>::ExpandAsB(in
   ARTYPE *val;
 
   // simplifying the notation.
-  
+
   val = (ARTYPE*)AsB.nzval;
   ind = AsB.rowind;
   col = AsB.colptr;
@@ -217,7 +218,7 @@ void ARluSymPencil<ARTYPE>::ExpandAsB(in
     for (i=0; i!=n; i++) {
       k = pcol[i+1];
       if ((k!=pcol[i])&&(ind[k-1]==i)) k--;
-      for (j=pcol[i]; j<k; j++) pos[ind[j]]++;        
+      for (j=pcol[i]; j<k; j++) pos[ind[j]]++;
     }
 
   }
@@ -226,16 +227,16 @@ void ARluSymPencil<ARTYPE>::ExpandAsB(in
     for (i=0; i!=n; i++) {
       k = pcol[i];
       if ((k!=pcol[i+1])&&(ind[k]==i)) k++;
-      for (j=k; j<pcol[i+1]; j++) pos[ind[j]]++;        
+      for (j=k; j<pcol[i+1]; j++) pos[ind[j]]++;
     }
 
-  }  
+  }
 
   // Summing up index elements.
 
   for (i=0; i<n; i++) pos[i+1] += pos[i];
   for (i=n; i>0; i--) col[i] += pos[i-1];
-    
+
   // Expanding A.
 
   if (uplo == 'U') {
@@ -279,11 +280,11 @@ void ARluSymPencil<ARTYPE>::ExpandAsB(in
 
   }
 
-  AsB.nnz = col[n]; 
+  AsB.nnz = col[n];
 
   //  Deleting temporary vectors.
 
-  delete[] pcol;  
+  delete[] pcol;
   delete[] pos;
 
 } // ExpandAsB.
@@ -321,9 +322,9 @@ SubtractAsB(int n, ARTYPE sigma, NCforma
   for (i=0; i!=n; i++) {
     bcol = matB.colptr[i];
     acol = matA.colptr[i];
-    SparseSaxpy(-sigma, &bnzval[bcol], &matB.rowind[bcol], 
-                matB.colptr[i+1]-bcol, &anzval[acol], &matA.rowind[acol], 
-                matA.colptr[i+1]-acol, &asbnzval[asbcol], 
+    SparseSaxpy(-sigma, &bnzval[bcol], &matB.rowind[bcol],
+                matB.colptr[i+1]-bcol, &anzval[acol], &matA.rowind[acol],
+                matA.colptr[i+1]-acol, &asbnzval[asbcol],
                 &AsB.rowind[asbcol], scol);
     asbcol += scol;
     AsB.colptr[i+1] = asbcol;
@@ -414,11 +415,11 @@ void ARluSymPencil<ARTYPE>::FactorAsB(AR
   // Permuting columns of AsB and
   // creating the elimination tree of AsB'*AsB.
 
-  sp_preorder("N", &AsB, permc, etree, &AC);
+  sp_preorder(APP_C_STR("N"), &AsB, permc, etree, &AC);
 
   // Decomposing AsB.
 
-  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
+  gstrf(APP_C_STR("N"),&AC, A->threshold, drop_tol, relax, panel_size, etree,
         NULL, 0, permr, permc, &L, &U, &info);
 
   // Deleting AC, AsB and etree.
@@ -478,7 +479,7 @@ void ARluSymPencil<ARTYPE>::MultInvAsBv(
 
   copy(A->nrows(), v, 1, w, 1);
   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
-  gstrs("N", &L, &U, permr, permc, &RHS, &info);
+  gstrs(APP_C_STR("N"), &L, &U, permr, permc, &RHS, &info);
 
   Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
 
@@ -506,9 +507,9 @@ DefineMatrices(ARluSymMatrix<ARTYPE>& Ap
 template<class ARTYPE>
 inline ARluSymPencil<ARTYPE>::ARluSymPencil()
 {
-  
-  factored = false; 
-  part     = 'N'; 
+
+  factored = false;
+  part     = 'N';
   permr    = NULL;
   permc    = NULL;
 
@@ -521,7 +522,7 @@ ARluSymPencil(ARluSymMatrix<ARTYPE>& Ap,
 {
 
   factored = false;
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/arlssym.h /usr/local/include/arpack++/arlssym.h
--- arpack++/include/arlssym.h	2000-03-04 02:43:06.000000000 +0530
+++ /usr/local/include/arpack++/arlssym.h	2016-11-17 18:22:42.136889211 +0530
@@ -19,7 +19,8 @@
 #ifndef ARLSSYM_H
 #define ARLSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arlsmat.h"
@@ -57,13 +58,13 @@ class ARluSymStdEig:
   // Short constructor.
 
   ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-                char* whichp = "LM", int ncvp = 0,
+                const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-                ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+                ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -92,7 +93,7 @@ inline void ARluSymStdEig<ARFLOAT>::Copy
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >:: Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -101,13 +102,13 @@ template<class ARFLOAT>
 inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -117,7 +118,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetR
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -127,7 +128,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
@@ -135,12 +136,12 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 template<class ARFLOAT>
 inline ARluSymStdEig<ARFLOAT>::
 ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-              char* whichp, int ncvp, ARFLOAT tolp,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultMv,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -149,14 +150,14 @@ ARluSymStdEig(int nevp, ARluSymMatrix<AR
 template<class ARFLOAT>
 inline ARluSymStdEig<ARFLOAT>::
 ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
-              ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+              ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultInvv,
+  this->DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
@@ -167,7 +168,7 @@ operator=(const ARluSymStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arpackf.h /usr/local/include/arpack++/arpackf.h
--- arpack++/include/arpackf.h	2000-02-21 05:20:00.000000000 +0530
+++ /usr/local/include/arpack++/arpackf.h	2016-11-17 18:22:42.136889211 +0530
@@ -24,7 +24,7 @@ extern "C"
 
 // debug "common" statement.
 
-  struct { 
+  extern struct { 
     ARint logfil, ndigit, mgetv0;
     ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;
     ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;
diff -rupN arpack++/include/arrgcomp.h /usr/local/include/arpack++/arrgcomp.h
--- arpack++/include/arrgcomp.h	2000-02-21 21:59:48.000000000 +0530
+++ /usr/local/include/arpack++/arrgcomp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARRGCOMP_H
 #define ARRGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrscomp.h"
 #include "arrgeig.h"
@@ -34,13 +35,13 @@ class ARrcCompGenEig:
   ARrcCompGenEig() { }
   // Short constructor (Does nothing but calling base classes constructors).
 
-  ARrcCompGenEig(int np, int nevp, char* whichp = "LM",
+  ARrcCompGenEig(int np, int nevp, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
-                 char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                 const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                  bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -66,27 +67,27 @@ class ARrcCompGenEig:
 
 template<class ARFLOAT>
 inline ARrcCompGenEig<ARFLOAT>::
-ARrcCompGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
+ARrcCompGenEig(int np, int nevp, const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
 inline ARrcCompGenEig<ARFLOAT>::
-ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap, char* whichp,
+ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap, const char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shif and invert mode).
 
@@ -97,7 +98,7 @@ operator=(const ARrcCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrgeig.h /usr/local/include/arpack++/arrgeig.h
--- arpack++/include/arrgeig.h	2000-02-21 21:58:50.000000000 +0530
+++ /usr/local/include/arpack++/arrgeig.h	2016-11-17 18:22:42.136889211 +0530
@@ -66,11 +66,11 @@ template<class ARFLOAT, class ARTYPE>
 inline void ARrcGenEig<ARFLOAT, ARTYPE>::NoShift()
 {
 
-  sigmaR    = (ARTYPE)0;
-  sigmaI    = 0.0;
-  mode      = 2;
-  iparam[7] = mode;
-  Restart();
+  this->sigmaR    = (ARTYPE)0;
+  this->sigmaI    = 0.0;
+  this->mode      = 2;
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // NoShift.
 
@@ -79,8 +79,8 @@ template<class ARFLOAT, class ARTYPE>
 inline ARrcGenEig<ARFLOAT, ARTYPE>::ARrcGenEig()
 {
 
-  bmat = 'G';   // This is a generalized problem.
-  NoShift();
+  this->bmat = 'G';   // This is a generalized problem.
+  this->NoShift();
 
 } // Short constructor.
 
@@ -91,7 +91,7 @@ operator=(const ARrcGenEig<ARFLOAT, ARTY
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrgnsym.h /usr/local/include/arpack++/arrgnsym.h
--- arpack++/include/arrgnsym.h	2000-02-21 21:57:48.000000000 +0530
+++ /usr/local/include/arpack++/arrgnsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARRGNSYM_H
 #define ARRGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrsnsym.h"
 #include "arrgeig.h"
@@ -50,7 +51,7 @@ class ARrcNonSymGenEig:
 
  // c.1) Functions that provides access to internal variables' values.
 
-  ARFLOAT GetShiftImag() { return sigmaI; }
+  ARFLOAT GetShiftImag() { return this->sigmaI; }
   // Returns the imaginary part of the shift (when in shift and invert mode).
 
 
@@ -66,7 +67,7 @@ class ARrcNonSymGenEig:
   virtual void SetShiftInvertMode(ARFLOAT sigmaRp);
   // Turns the problem to real shift-and-invert mode with sigmaRp as shift.
 
-  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp, 
+  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp,
                                    ARFLOAT sigmaIp);
   // Turns the problem to complex shift-and-invert mode with shift
   // defined by sigmaRp and sigmaIp.
@@ -77,21 +78,21 @@ class ARrcNonSymGenEig:
   ARrcNonSymGenEig() { part = 'R'; }
   // Short constructor that does almost nothing.
 
-  ARrcNonSymGenEig(int np, int nevp, char* whichp = "LM",
+  ARrcNonSymGenEig(int np, int nevp, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap,
-                   char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
-                   int maxitp = 0, ARFLOAT* residp = NULL, 
+                   const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                   int maxitp = 0, ARFLOAT* residp = NULL,
                    bool ishiftp = true);
   // Long constructor (real shift and invert mode).
 
   ARrcNonSymGenEig(int np, int nevp,
                    char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
-                   char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
-                   int maxitp = 0, ARFLOAT* residp = NULL, 
+                   const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                   int maxitp = 0, ARFLOAT* residp = NULL,
                    bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
 
@@ -141,13 +142,13 @@ inline void ARrcNonSymGenEig<ARFLOAT>::C
 
   part = CheckPart(partp);
   if (part == 'R') {
-    mode    = 3;    // Real part.
+    this->mode    = 3;    // Real part.
   }
   else {
-    mode    = 4;    // Imaginary part.
+    this->mode    = 4;    // Imaginary part.
   }
-  iparam[7] = mode;
-  Restart();
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // ChangePart.
 
@@ -157,8 +158,8 @@ inline void ARrcNonSymGenEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = sigmaIp;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = sigmaIp;
   ChangePart(part);
 
 } // ChangeShift.
@@ -170,7 +171,7 @@ SetShiftInvertMode(ARFLOAT sigmaRp)
 {
 
   part = 'R';
-  ChangeShift(sigmaRp);
+  this->ChangeShift(sigmaRp);
 
 } // SetShiftInvertMode.
 
@@ -181,32 +182,32 @@ SetComplexShiftMode(char partp, ARFLOAT
 {
 
   part   = CheckPart(partp);
-  ChangeShift(sigmaRp, sigmaIp);
+  this->ChangeShift(sigmaRp, sigmaIp);
 
 } // SetComplexShiftMode.
 
 
 template<class ARFLOAT>
 inline ARrcNonSymGenEig<ARFLOAT>::
-ARrcNonSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
+ARrcNonSymGenEig(int np, int nevp, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
   part = 'R';                // Considering mode = 3 in ChangeShift.
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
 inline ARrcNonSymGenEig<ARFLOAT>::
-ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,
+ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
   SetShiftInvertMode(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 
 } // Long constructor (real shift and invert mode).
@@ -215,12 +216,12 @@ ARrcNonSymGenEig(int np, int nevp, ARFLO
 template<class ARFLOAT>
 inline ARrcNonSymGenEig<ARFLOAT>::
 ARrcNonSymGenEig(int np, int nevp, char partp, ARFLOAT sigmaRp,
-                 ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
+                 ARFLOAT sigmaIp, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
   SetComplexShiftMode(partp, sigmaRp, sigmaIp);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
 
@@ -231,7 +232,7 @@ operator=(const ARrcNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrgsym.h /usr/local/include/arpack++/arrgsym.h
--- arpack++/include/arrgsym.h	2000-02-21 20:20:06.000000000 +0530
+++ /usr/local/include/arpack++/arrgsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARRGSYM_H
 #define ARRGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrssym.h"
 #include "arrgeig.h"
@@ -72,13 +73,13 @@ class ARrcSymGenEig:
   ARrcSymGenEig() { InvertMode = 'S'; }
   // Short constructor that does almost nothing.
 
-  ARrcSymGenEig(int np, int nevp, char* whichp = "LM",
+  ARrcSymGenEig(int np, int nevp, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARrcSymGenEig(char invertmodep, int np, int nevp, ARFLOAT sigmap,
-                char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                 int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift-and-invert, buckling and Cayley modes).
 
@@ -129,17 +130,17 @@ inline void ARrcSymGenEig<ARFLOAT>::Chan
   InvertMode = CheckInvertMode(InvertModep);
   switch (InvertMode) {
   case 'S':
-    mode    = 3;    // Shift and invert mode.
+    this->mode    = 3;    // Shift and invert mode.
     break;
   case 'B':
-    mode    = 4;    // Buckling mode.
+    this->mode    = 4;    // Buckling mode.
     break;
   case 'C':
-    mode    = 5;    // Cayley mode.
+    this->mode    = 5;    // Cayley mode.
     break;
   }
-  iparam[7] = mode;
-  Restart();
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // ChangeInvertMode.
 
@@ -148,8 +149,8 @@ template<class ARFLOAT>
 inline void ARrcSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  sigmaR    = sigmap;
-  sigmaI    = 0.0;
+  this->sigmaR    = sigmap;
+  this->sigmaI    = 0.0;
   ChangeInvertMode(InvertMode);
 
 } // ChangeShift.
@@ -161,7 +162,7 @@ void ARrcSymGenEig<ARFLOAT>::SetShiftInv
 {
 
   InvertMode = 'S';
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // SetShiftInvertMode.
 
@@ -172,7 +173,7 @@ void ARrcSymGenEig<ARFLOAT>::SetBuckling
 {
 
   InvertMode = 'B';
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // SetBucklingMode.
 
@@ -183,21 +184,21 @@ void ARrcSymGenEig<ARFLOAT>::SetCayleyMo
 {
 
   InvertMode = 'C';
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // SetCayleyMode.
 
 
 template<class ARFLOAT>
 inline ARrcSymGenEig<ARFLOAT>::
-ARrcSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
+ARrcSymGenEig(int np, int nevp, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   InvertMode = 'S';   // Considering mode = 3 in ChangeShift.
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
@@ -205,14 +206,14 @@ ARrcSymGenEig(int np, int nevp, char* wh
 template<class ARFLOAT>
 inline ARrcSymGenEig<ARFLOAT>::
 ARrcSymGenEig(char InvertModep, int np, int nevp,
-              ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+              ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S', 'B', 'C'.
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift-and-invert, buckling and Cayley modes).
 
@@ -223,7 +224,7 @@ operator=(const ARrcSymGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrscomp.h /usr/local/include/arpack++/arrscomp.h
--- arpack++/include/arrscomp.h	2000-03-04 01:59:58.000000000 +0530
+++ /usr/local/include/arpack++/arrscomp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARRSCOMP_H
 #define ARRSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -55,10 +56,10 @@ class ARrcCompStdEig: virtual public ARr
   void Trace(const int digit = -5, const int getv0 = 0, const int aupd = 1,
              const int aup2 = 0,  const int aitr = 0,  const int eigt = 0,
              const int apps = 0,  const int gets = 0,  const int eupd = 0)
-  { 
-    cTraceOn(digit, getv0, aupd, aup2, aitr, eigt, apps, gets, eupd); 
+  {
+    cTraceOn(digit, getv0, aupd, aup2, aitr, eigt, apps, gets, eupd);
   }
-  // Turns on trace mode. 
+  // Turns on trace mode.
 
 
  // b.2) Functions that perform all calculations in one step.
@@ -68,7 +69,7 @@ class ARrcCompStdEig: virtual public ARr
   // Overrides array EigValp with the eigenvalues of the problem.
   // Also calculates eigenvectors and Schur vectors if requested.
 
-  int EigenValVectors(arcomplex<ARFLOAT>* &EigVecp, 
+  int EigenValVectors(arcomplex<ARFLOAT>* &EigVecp,
                       arcomplex<ARFLOAT>* &EigValp, bool ischur = false);
   // Overrides array EigVecp sequentially with the eigenvectors of the
   // given eigen-problem. Also stores the eigenvalues in EigValp.
@@ -104,13 +105,13 @@ class ARrcCompStdEig: virtual public ARr
   ARrcCompStdEig() { }
   // Short constructor.
 
-  ARrcCompStdEig(int np, int nevp, char* whichp = "LM",
+  ARrcCompStdEig(int np, int nevp, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigma,
-                 char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                 const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                  bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -138,12 +139,12 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = ncv*(3*ncv+6);
-  lworkv  = 2*ncv;
-  lrwork  = ncv;
-  workl   = new arcomplex<ARFLOAT>[lworkl+1];
-  workv   = new arcomplex<ARFLOAT>[lworkv+1];
-  rwork   = new ARFLOAT[lrwork+1];
+  this->lworkl  = this->ncv*(3*this->ncv+6);
+  this->lworkv  = 2*this->ncv;
+  this->lrwork  = this->ncv;
+  this->workl   = new arcomplex<ARFLOAT>[this->lworkl+1];
+  this->workv   = new arcomplex<ARFLOAT>[this->lworkv+1];
+  this->rwork   = new ARFLOAT[this->lrwork+1];
 
 } // WorkspaceAllocate.
 
@@ -152,8 +153,8 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::Aupp()
 {
 
-  caupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, rwork, info);
+  caupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
 
 } // Aupp.
 
@@ -162,9 +163,9 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::Eupp()
 {
 
-  ceupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, workv,
-        bmat, n, which, nev, tol, resid, ncv, V, n, iparam,
-        ipntr, workd, workl, lworkl, rwork, info);
+  ceupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->workv,
+        this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
+        this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
 
 } // Eupp.
 
@@ -174,36 +175,36 @@ int ARrcCompStdEig<ARFLOAT>::
 Eigenvalues(arcomplex<ARFLOAT>* &EigValp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                      // Eigenvalues are available .
+  if (this->ValuesOK) {                      // Eigenvalues are available .
     if (EigValp == NULL) {             // Moving eigenvalues.
-      EigValp  = EigValR;
-      EigValR  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValp  = this->EigValR;
+      this->EigValR  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                             // Copying eigenvalues.
-      copy(nconv,EigValR,1,EigValp,1);
+      copy(this->nconv,this->EigValR,1,EigValp,1);
     }
   }
   else {
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
     if (EigValp == NULL) {
-      try { EigValp = new arcomplex<ARFLOAT>[ValSize()]; }
+      try { EigValp = new arcomplex<ARFLOAT>[this->ValSize()]; }
       catch (ArpackError) { return 0; }
     }
-    EigValR = EigValp;
+    this->EigValR = EigValp;
     if (ivec) {                        // Finding eigenvalues and eigenvectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                             // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValp, ivec, ischur).
 
@@ -214,31 +215,31 @@ EigenValVectors(arcomplex<ARFLOAT>* &Eig
                 bool ischur)
 {
 
-  if (ValuesOK) {                  // Eigenvalues are already available.
-    nconv = Eigenvalues(EigValp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {                  // Eigenvalues are already available.
+    this->nconv = Eigenvalues(EigValp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                           // Eigenvalues and vectors are not available.
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
+    }
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
-    }  
     try {
-      if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[ValSize()*n];
-      if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[ValSize()];
+      if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[this->ValSize()*this->n];
+      if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[this->ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigVec  = EigVecp;
-    EigValR = EigValp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValp, ischur).
 
@@ -251,13 +252,13 @@ inline arcomplex<ARFLOAT> ARrcCompStdEig
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // Eigenvalue(i).
 
@@ -269,13 +270,13 @@ Eigenvector(int i, int j)
 
   // Returning element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // Eigenvector(i,j).
 
@@ -331,13 +332,13 @@ StlEigenvector(int i)
 
 template<class ARFLOAT>
 inline ARrcCompStdEig<ARFLOAT>::
-ARrcCompStdEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
+ARrcCompStdEig(int np, int nevp, const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
@@ -345,13 +346,13 @@ ARrcCompStdEig(int np, int nevp, char* w
 template<class ARFLOAT>
 inline ARrcCompStdEig<ARFLOAT>::
 ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
-               char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+               const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
 
@@ -362,7 +363,7 @@ operator=(const ARrcCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrseig.h /usr/local/include/arpack++/arrseig.h
--- arpack++/include/arrseig.h	2000-03-04 02:39:44.000000000 +0530
+++ /usr/local/include/arpack++/arrseig.h	2016-11-17 18:22:42.136889211 +0530
@@ -19,8 +19,9 @@
 #ifndef ARRSEIG_H
 #define ARRSEIG_H
 
-#include <new.h>
-#include <stddef.h>
+#include <new>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -29,7 +30,7 @@
 
 // "New" handler.
 
-void MemoryOverflow() { throw ArpackError(ArpackError::MEMORY_OVERFLOW); }
+inline void MemoryOverflow() { throw ArpackError(ArpackError::MEMORY_OVERFLOW); }
 
 // ARrcStdEig class definition.
 
@@ -188,7 +189,7 @@ class ARrcStdEig {
 
  // c.1) Function that stores user defined parameters.
 
-  virtual void DefineParameters(int np, int nevp, char* whichp="LM",
+  virtual void DefineParameters(int np, int nevp, const char* whichp="LM",
                                 int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                 ARTYPE* residp=NULL, bool ishiftp=true);
   // Set values of problem parameters (also called by constructors).
@@ -475,9 +476,9 @@ inline void ARrcStdEig<ARFLOAT, ARTYPE>:
 template<class ARFLOAT, class ARTYPE>
 void ARrcStdEig<ARFLOAT, ARTYPE>::ClearMem()
 {
- 
+
   // Deleting working arrays.
-    
+
   delete[] workl;
   delete[] workd;
   delete[] workv;
@@ -515,7 +516,7 @@ void ARrcStdEig<ARFLOAT, ARTYPE>::ClearM
   // Adjusting boolean variables.
 
   ClearFirst();
-  
+
 } // ClearMem.
 
 
@@ -642,7 +643,7 @@ template<class ARFLOAT, class ARTYPE>
 inline int ARrcStdEig<ARFLOAT, ARTYPE>::CheckNev(int nevp)
 {
 
-  if ((nevp<1)||(nevp>=n)) { 
+  if ((nevp<1)||(nevp>=n)) {
     throw ArpackError(ArpackError::NEV_OUT_OF_BOUNDS);
   }
   return nevp;
@@ -830,14 +831,14 @@ void ARrcStdEig<ARFLOAT,ARTYPE>::Copy(co
 
 template<class ARFLOAT, class ARTYPE>
 void ARrcStdEig<ARFLOAT, ARTYPE>::
-DefineParameters(int np, int nevp, char* whichp, int ncvp,
+DefineParameters(int np, int nevp, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARTYPE* residp, bool ishiftp)
 
 {
 
   // Providing a "new" handler.
 
-  set_new_handler(MemoryOverflow);
+  std::set_new_handler ( MemoryOverflow );
 
   // Setting user defined parameters.
 
@@ -845,7 +846,7 @@ DefineParameters(int np, int nevp, char*
     n         = CheckN(np);
     nev       = CheckNev(nevp);
     ncv       = CheckNcv(ncvp);
-    which     = CheckWhich(whichp);
+    which     = CheckWhich(const_cast<char *>(whichp));
     maxit     = CheckMaxit(maxitp);
     tol       = tolp;
     resid     = residp;
@@ -905,8 +906,8 @@ template<class ARFLOAT, class ARTYPE>
 void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeNev(int nevp)
 {
 
-  try { 
-    nev = CheckNev(nevp); 
+  try {
+    nev = CheckNev(nevp);
     ncv = CheckNcv(ncv);
   }
   catch (ArpackError) { return; }
@@ -1427,7 +1428,7 @@ inline vector<ARTYPE>* ARrcStdEig<ARFLOA
 
   if (!SchurOK) {
     nconv = FindSchurVectors();
-  } 
+  }
   try {
     StlSchurVec = new vector<ARTYPE>(&V[1], &V[nev*n+1]);
   }
diff -rupN arpack++/include/arrsnsym.h /usr/local/include/arpack++/arrsnsym.h
--- arpack++/include/arrsnsym.h	2000-03-04 02:00:50.000000000 +0530
+++ /usr/local/include/arpack++/arrsnsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARRSNSYM_H
 #define ARRSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -35,7 +36,7 @@ class ARrcNonSymStdEig: public virtual A
 
  // a.1) Memory control functions.
 
-  int ValSize() { return nev+1; }
+  int ValSize() { return this->nev+1; }
   // Provides the size of array EigVal.
 
   void ValAllocate();
@@ -63,20 +64,20 @@ class ARrcNonSymStdEig: public virtual A
  // a.4) Auxiliary functions required when using STL vector class.
 
   bool ConjEigVec(int i);
-  // Indicates if EigVec[i] is the second eigenvector in 
+  // Indicates if EigVec[i] is the second eigenvector in
   // a complex conjugate pair.
 
 #ifdef ARCOMP_H
 #ifdef STL_VECTOR_H
 
-  vector<arcomplex<ARFLOAT> >* GenComplex(vector<ARFLOAT>* RealPart, 
-                                          vector<ARFLOAT>* ImagPart, 
+  vector<arcomplex<ARFLOAT> >* GenComplex(vector<ARFLOAT>* RealPart,
+                                          vector<ARFLOAT>* ImagPart,
                                           bool conj = false);
   // Generates a complex vector Complex = RealPart + I*ImagPart
   // (or Complex = RealPart - I*ImagPart, if conj = true).
 
-  vector<arcomplex<ARFLOAT> >* GenComplex(int dim, ARFLOAT* RealPart, 
-                                          ARFLOAT* ImagPart, 
+  vector<arcomplex<ARFLOAT> >* GenComplex(int dim, ARFLOAT* RealPart,
+                                          ARFLOAT* ImagPart,
                                           bool conj = false);
   // Generates a complex vector Complex = RealPart + I*ImagPart
   // (or Complex = RealPart - I*ImagPart, if conj = true). dim
@@ -99,9 +100,9 @@ class ARrcNonSymStdEig: public virtual A
              const int aup2 = 0,  const int aitr = 0,  const int eigt = 0,
              const int apps = 0,  const int gets = 0,  const int eupd = 0)
   {
-    nTraceOn(digit, getv0, aupd, aup2, aitr, eigt, apps, gets, eupd); 
+    nTraceOn(digit, getv0, aupd, aup2, aitr, eigt, apps, gets, eupd);
   }
-  // Turns on trace mode. 
+  // Turns on trace mode.
 
 
  // b.2) Functions that permit step by step execution of ARPACK.
@@ -115,11 +116,11 @@ class ARrcNonSymStdEig: public virtual A
 
   int Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp,
                   bool ivec = false, bool ischur = false);
-  // Overrides arrays EigValRp with the real part and EigValIp 
-  // with the imaginary part of the eigenvalues of the problem. 
+  // Overrides arrays EigValRp with the real part and EigValIp
+  // with the imaginary part of the eigenvalues of the problem.
   // Calculates eigenvectors and Schur vectors if requested.
 
-  int EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValRp, 
+  int EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValRp,
                       ARFLOAT* &EigValIp, bool ischur = false);
   // Overrides array EigVecp sequentially with the eigenvectors of the
   // given eigen-problem. Also stores the eigenvalues in EigValRp and
@@ -162,7 +163,7 @@ class ARrcNonSymStdEig: public virtual A
 #ifdef STL_VECTOR_H
 
 #ifdef ARCOMP_H
-  vector<arcomplex<ARFLOAT> >* StlEigenvalues(bool ivec = false, 
+  vector<arcomplex<ARFLOAT> >* StlEigenvalues(bool ivec = false,
                                               bool ischur = false);
   // Calculates the eigenvalues and stores them in a single STL vector.
   // Also calculates eigenvectors and Schur vectors if requested.
@@ -193,12 +194,12 @@ class ARrcNonSymStdEig: public virtual A
   ARrcNonSymStdEig() { }
   // Short constructor.
 
-  ARrcNonSymStdEig(int np, int nevp, char* whichp = "LM", int ncvp = 0,
+  ARrcNonSymStdEig(int np, int nevp, const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                    bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigma, char* whichp = "LM",
+  ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigma, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -226,10 +227,10 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::ValAllocate()
 {
 
-  if (EigValR == NULL) {
-    EigValR = new ARFLOAT[ValSize()];
-    EigValI = new ARFLOAT[ValSize()];
-    newVal = true;
+  if (this->EigValR == NULL) {
+    this->EigValR = new ARFLOAT[ValSize()];
+    this->EigValI = new ARFLOAT[ValSize()];
+    this->newVal = true;
   }
 
 } // ValAllocate.
@@ -239,11 +240,11 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = 3*ncv*(ncv+2);
-  lworkv  = 3*ncv;
-  lrwork  = 0;
-  workl   = new ARFLOAT[lworkl+1];
-  workv   = new ARFLOAT[lworkv+1];
+  this->lworkl  = 3*this->ncv*(this->ncv+2);
+  this->lworkv  = 3*this->ncv;
+  this->lrwork  = 0;
+  this->workl   = new ARFLOAT[this->lworkl+1];
+  this->workv   = new ARFLOAT[this->lworkv+1];
 
 } // WorkspaceAllocate.
 
@@ -252,8 +253,8 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::Aupp()
 {
 
-  naupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, info);
+  naupp(this->ido,this-> bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Aupp.
 
@@ -262,9 +263,9 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::Eupp()
 {
 
-  neupp(rvec, HowMny, EigValR, EigValI, EigVec, n, sigmaR,
-        sigmaI, workv, bmat, n, which, nev, tol, resid, ncv, V,
-        n, iparam, ipntr, workd, workl, lworkl, info);
+  neupp(this->rvec, this->HowMny, this->EigValR, this->EigValI, this->EigVec, this->n, this->sigmaR,
+        this->sigmaI, this->workv, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V,
+        this->n, this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Eupp.
 
@@ -273,7 +274,7 @@ template<class ARFLOAT>
 inline int ARrcNonSymStdEig<ARFLOAT>::CheckNev(int nevp)
 {
 
-  if ((nevp<=1)||(nevp>=(n-1))) { // nev must satisfy 1 < nev < n-1.
+  if ((nevp<=1)||(nevp>=(this->n-1))) { // nev must satisfy 1 < nev < n-1.
     throw ArpackError(ArpackError::NEV_OUT_OF_BOUNDS);
   }
   return nevp;
@@ -285,9 +286,9 @@ template<class ARFLOAT>
 bool ARrcNonSymStdEig<ARFLOAT>::ConjEigVec(int i)
 {
 
-  if (EigValI[i] == (ARFLOAT)0.0) return false;
+  if (this->EigValI[i] == (ARFLOAT)0.0) return false;
   int j = i-1;
-  while ((j >= 0) && (EigValI[j] != (ARFLOAT)0.0)) j--;
+  while ((j >= 0) && (this->EigValI[j] != (ARFLOAT)0.0)) j--;
   if (((i-j)%2) == 0) {
     return true;
   }
@@ -344,8 +345,8 @@ GenComplex(int dim, ARFLOAT* RealPart, A
     Result = new vector<arcomplex<ARFLOAT> >(dim);
   }
   catch (ArpackError) { return NULL; }
-  ARFLOAT* rp  = RealPart; 
-  ARFLOAT* ip  = ImagPart; 
+  ARFLOAT* rp  = RealPart;
+  ARFLOAT* ip  = ImagPart;
   ARFLOAT* end = &RealPart[dim];
   arcomplex<ARFLOAT>* s = Result->begin();
 
@@ -375,7 +376,7 @@ GenComplex(int dim, ARFLOAT* RealPart)
     Result = new vector<arcomplex<ARFLOAT> >(dim);
   }
   catch (ArpackError) { return NULL; }
-  ARFLOAT* rp  = RealPart; 
+  ARFLOAT* rp  = RealPart;
   ARFLOAT* end = &RealPart[dim];
   arcomplex<ARFLOAT>* s = Result->begin();
 
@@ -395,10 +396,10 @@ template<class ARFLOAT>
 ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::GetVectorImag()
 {
 
-  if (ido != 3) {
+  if (this->ido != 3) {
     throw ArpackError(ArpackError::CANNOT_GET_VECTOR, "GetVectorImag");
   }
-  return &workl[ipntr[6]];
+  return &this->workl[this->ipntr[6]];
 
 } // GetVectorImag.
 
@@ -408,14 +409,14 @@ int ARrcNonSymStdEig<ARFLOAT>::
 Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                                 // Eigenvalues are available.
+  if (this->ValuesOK) {                                 // Eigenvalues are available.
     if ((EigValRp == NULL)&&(EigValIp == NULL)) { // Moving eigenvalues.
-      EigValRp = EigValR;
-      EigValIp = EigValI;
-      EigValR  = NULL;
-      EigValI  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValRp = this->EigValR;
+      EigValIp = this->EigValI;
+      this->EigValR  = NULL;
+      this->EigValI  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                                        // Copying eigenvalues.
       try {
@@ -423,33 +424,33 @@ Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT*
         if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
       }
       catch (ArpackError) { return 0; }
-      copy(nconv,EigValR,1,EigValRp,1);
-      copy(nconv,EigValI,1,EigValIp,1);
+      copy(this->nconv,this->EigValR,1,EigValRp,1);
+      copy(this->nconv,this->EigValI,1,EigValIp,1);
     }
   }
   else {
-    if (newVal) {
-      delete[] EigValR;
-      delete[] EigValI;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      delete[] this->EigValI;
+      this->newVal = false;
     }
     try {
       if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
       if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigValR = EigValRp;
-    EigValI = EigValIp;
+    this->EigValR = EigValRp;
+    this->EigValI = EigValIp;
     if (ivec) {                              // Finding eigenvalues and vectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                                   // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
-    EigValI = NULL;
+    this->EigValR = NULL;
+    this->EigValI = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValRp, EigValIp, ivec, ischur).
 
@@ -460,35 +461,35 @@ EigenValVectors(ARFLOAT* &EigVecp, ARFLO
                 ARFLOAT* &EigValIp, bool ischur)
 {
 
-  if (ValuesOK) {               // Eigenvalues are already available .
-    nconv = Eigenvalues(EigValRp, EigValIp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {               // Eigenvalues are already available .
+    this->nconv = Eigenvalues(EigValRp, EigValIp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                        // Eigenvalues ans vectors are not available.
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
-    }
-    if (newVal) {
-      delete[] EigValR;
-      delete[] EigValI;
-      newVal = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
+    }
+    if (this->newVal) {
+      delete[] this->EigValR;
+      delete[] this->EigValI;
+      this->newVal = false;
     }
     try {
-      if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*n];
+      if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*this->n];
       if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
       if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigVec  = EigVecp;
-    EigValR = EigValRp;
-    EigValI = EigValIp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
-    EigValI = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValRp;
+    this->EigValI = EigValIp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
+    this->EigValI = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValRp, EigValIp, ischur).
 
@@ -500,13 +501,13 @@ inline arcomplex<ARFLOAT> ARrcNonSymStdE
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return arcomplex<ARFLOAT>(EigValR[i],EigValI[i]);
+  return arcomplex<ARFLOAT>(this->EigValR[i],this->EigValI[i]);
 
 } // Eigenvalue(i).
 #endif // ARCOMP_H
@@ -518,13 +519,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the real part of i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueReal(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueReal(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // EigenvalueReal(i).
 
@@ -535,13 +536,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the imaginary part of i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueImag(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueImag(i)");
   }
-  return EigValI[i];
+  return this->EigValI[i];
 
 } // EigenvalueImag(i).
 
@@ -554,21 +555,21 @@ Eigenvector(int i, int j)
 
   // Returning element j of i-eth eigenvector.
 
-  if ((!VectorsOK)||(!ValuesOK)) {
+  if ((!this->VectorsOK)||(!this->ValuesOK)) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
-    return arcomplex<ARFLOAT>(EigVec[i*n+j],(ARFLOAT)0.0);
+  if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
+    return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j],(ARFLOAT)0.0);
   }
   else {                            // Complex eigenvalue.
-    if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
-      return arcomplex<ARFLOAT>(EigVec[i*n+j], EigVec[(i+1)*n+j]);
+    if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
+      return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j], this->EigVec[(i+1)*this->n+j]);
     }
     else {                          // with negative imaginary part.
-      return arcomplex<ARFLOAT>(EigVec[(i-1)*n+j], -EigVec[i*n+j]);
+      return arcomplex<ARFLOAT>(this->EigVec[(i-1)*this->n+j], -this->EigVec[i*this->n+j]);
     }
   }
 
@@ -582,13 +583,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the real part of element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorReal(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorReal(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // EigenvectorReal(i,j).
 
@@ -599,21 +600,21 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the imaginary part of element j of i-eth eigenvector.
 
-  if ((!VectorsOK)||(!ValuesOK)) {
+  if ((!this->VectorsOK)||(!this->ValuesOK)) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorImag(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorImag(i,j)");
   }
-  if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
+  if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
     return (ARFLOAT)0.0;
   }
   else {                            // Complex eigenvalue.
-    if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
-      return EigVec[(i+1)*n+j];
+    if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
+      return this->EigVec[(i+1)*this->n+j];
     }
     else {                          // with negative imaginary part.
-      return -EigVec[i*n+j];
+      return -this->EigVec[i*this->n+j];
     }
   }
 
@@ -624,10 +625,10 @@ template<class ARFLOAT>
 inline ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::RawEigenvaluesImag()
 {
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "RawEigenvaluesImag");
   }
-  return EigValI;
+  return this->EigValI;
 
 } // RawEigenvaluesImag.
 
@@ -680,7 +681,7 @@ inline vector<ARFLOAT>* ARrcNonSymStdEig
   // Returning the real part of the eigenvalues in a STL vector.
 
   vector<ARFLOAT>* StlEigValR;
-  
+
   if (!ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "StlEigenvaluesReal");
   }
@@ -817,26 +818,26 @@ inline vector<ARFLOAT>* ARrcNonSymStdEig
 
 template<class ARFLOAT>
 inline ARrcNonSymStdEig<ARFLOAT>::
-ARrcNonSymStdEig(int np, int nevp, char* whichp, int ncvp,
+ARrcNonSymStdEig(int np, int nevp, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
 inline ARrcNonSymStdEig<ARFLOAT>::
-ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,
+ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigmap, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
 
@@ -847,7 +848,7 @@ operator=(const ARrcNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arrssym.h /usr/local/include/arpack++/arrssym.h
--- arpack++/include/arrssym.h	2000-03-04 01:59:21.000000000 +0530
+++ /usr/local/include/arpack++/arrssym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,7 @@
 #ifndef ARRSSYM_H
 #define ARRSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -62,11 +62,11 @@ class ARrcSymStdEig: public virtual ARrc
 
   void Trace(const int digit = -5, const int getv0 = 0, const int aupd = 1,
              const int aup2 = 0,  const int aitr = 0,  const int eigt = 0,
-             const int apps = 0,  const int gets = 0,  const int eupd = 0) 
-  { 
+             const int apps = 0,  const int gets = 0,  const int eupd = 0)
+  {
     sTraceOn(digit, getv0, aupd, aup2, aitr, eigt, apps, gets, eupd);
   }
-  // Turns on trace mode. 
+  // Turns on trace mode.
 
 
  // b.2) Functions that permit step by step execution of ARPACK.
@@ -89,7 +89,7 @@ class ARrcSymStdEig: public virtual ARrc
   // Overrides array EigValp with the eigenvalues of the problem.
   // Also calculates eigenvectors and Schur vectors if requested.
 
-  int EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, 
+  int EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp,
                       bool ischur = false);
   // Overrides array EigVecp sequentially with the eigenvectors of the
   // given eigen-problem. Also stores the eigenvalues in EigValp.
@@ -124,12 +124,12 @@ class ARrcSymStdEig: public virtual ARrc
   ARrcSymStdEig() { }
   // Short constructor.
 
-  ARrcSymStdEig(int np, int nevp, char* whichp = "LM", int ncvp = 0,
+  ARrcSymStdEig(int np, int nevp, const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                 bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp = "LM",
+  ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -157,10 +157,10 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = ncv*(ncv+9);
-  lworkv  = 0;
-  lrwork  = 0;
-  workl   = new ARFLOAT[lworkl+1];
+  this->lworkl  = this->ncv*(this->ncv+9);
+  this->lworkv  = 0;
+  this->lrwork  = 0;
+  this->workl   = new ARFLOAT[this->lworkl+1];
 
 } // WorkspaceAllocate.
 
@@ -169,8 +169,8 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::Aupp()
 {
 
-  saupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, info);
+  saupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Aupp.
 
@@ -179,9 +179,9 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::Eupp()
 {
 
-  seupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, bmat,
-        n, which, nev, tol, resid, ncv, V, n, iparam,
-        ipntr, workd, workl, lworkl, info);
+  seupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->bmat,
+        this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
+        this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Eupp.
 
@@ -211,13 +211,13 @@ template<class ARFLOAT>
 ARFLOAT* ARrcSymStdEig<ARFLOAT>::PutVector()
 {
 
-  switch (ido) {
+  switch (this->ido) {
   case -1:
   case  1:                    // Returning OP*x.
   case  2:
-    return &workd[ipntr[2]];  // Returning B*x.
+    return &this->workd[this->ipntr[2]];  // Returning B*x.
   case  3:
-    return &workl[ipntr[11]]; // Returning shifts.
+    return &this->workl[this->ipntr[11]]; // Returning shifts.
   default:
     throw ArpackError(ArpackError::CANNOT_PUT_VECTOR, "PutVector");
   }
@@ -230,36 +230,36 @@ int ARrcSymStdEig<ARFLOAT>::
 Eigenvalues(ARFLOAT* &EigValp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                      // Eigenvalues are available.
+  if (this->ValuesOK) {                      // Eigenvalues are available.
     if (EigValp == NULL) {             // Moving eigenvalues.
-      EigValp  = EigValR;
-      EigValR  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValp  = this->EigValR;
+      this->EigValR  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                             // Copying eigenvalues.
-      copy(nconv,EigValR,1,EigValp,1);
+      copy(this->nconv,this->EigValR,1,EigValp,1);
     }
   }
   else {                               // Eigenvalues are not available.
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
     if (EigValp == NULL) {
-      try { EigValp = new ARFLOAT[ValSize()]; }
+      try { EigValp = new ARFLOAT[this->ValSize()]; }
       catch (ArpackError) { return 0; }
     }
-    EigValR = EigValp;
+    this->EigValR = EigValp;
     if (ivec) {                        // Finding eigenvalues and eigenvectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                             // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValp, ivec, ischur).
 
@@ -269,31 +269,31 @@ int ARrcSymStdEig<ARFLOAT>::
 EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, bool ischur)
 {
 
-  if (ValuesOK) {                  // Eigenvalues are already available .
-    nconv = Eigenvalues(EigValp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {                  // Eigenvalues are already available .
+    this->nconv = Eigenvalues(EigValp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                           // Eigenvalues and vectors are not available.
     try {
-      if (EigVecp == NULL) EigVecp = new ARFLOAT[ValSize()*n];
-      if (EigValp == NULL) EigValp = new ARFLOAT[ValSize()];
+      if (EigVecp == NULL) EigVecp = new ARFLOAT[this->ValSize()*this->n];
+      if (EigValp == NULL) EigValp = new ARFLOAT[this->ValSize()];
     }
     catch (ArpackError) { return 0; }
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
     }
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
-    EigVec  = EigVecp;
-    EigValR = EigValp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValp, ischur).
 
@@ -304,13 +304,13 @@ inline ARFLOAT ARrcSymStdEig<ARFLOAT>::E
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // Eigenvalue(i).
 
@@ -321,13 +321,13 @@ inline ARFLOAT ARrcSymStdEig<ARFLOAT>::E
 
   // Returning element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // Eigenvector(i,j).
 
@@ -380,27 +380,27 @@ inline vector<ARFLOAT>* ARrcSymStdEig<AR
 
 template<class ARFLOAT>
 inline ARrcSymStdEig<ARFLOAT>::
-ARrcSymStdEig(int np, int nevp, char* whichp, int ncvp,
+ARrcSymStdEig(int np, int nevp, const char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->NoShift();
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
 inline ARrcSymStdEig<ARFLOAT>::
-ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp,
+ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, const char* whichp,
               int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp,
               bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
 
@@ -411,7 +411,7 @@ operator=(const ARrcSymStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arscomp.h /usr/local/include/arpack++/arscomp.h
--- arpack++/include/arscomp.h	2000-02-21 19:06:40.000000000 +0530
+++ /usr/local/include/arpack++/arscomp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARSCOMP_H
 #define ARSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrscomp.h"
@@ -36,14 +37,14 @@ class ARCompStdEig:
 
   ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
-               char* whichp = "LM", int ncvp = 0,
+               const char* whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0,
                arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
-               arcomplex<ARFLOAT> sigma,  char* whichp = "LM",
+               arcomplex<ARFLOAT> sigma,  const char* whichp = "LM",
                int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -71,13 +72,13 @@ template<class ARFLOAT, class ARFOP>
 inline ARCompStdEig<ARFLOAT, ARFOP>::
 ARCompStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
-             char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+             const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
              arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -87,14 +88,14 @@ template<class ARFLOAT, class ARFOP>
 inline ARCompStdEig<ARFLOAT, ARFOP>::
 ARCompStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
-             arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+             arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
              ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
              bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
@@ -106,7 +107,7 @@ operator=(const ARCompStdEig<ARFLOAT, AR
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -115,4 +116,3 @@ operator=(const ARCompStdEig<ARFLOAT, AR
 
 
 #endif // ARSCOMP_H
-
diff -rupN arpack++/include/arseig.h /usr/local/include/arpack++/arseig.h
--- arpack++/include/arseig.h	2000-03-03 21:44:14.000000000 +0530
+++ /usr/local/include/arpack++/arseig.h	2016-11-17 18:22:42.136889211 +0530
@@ -19,7 +19,7 @@
 #ifndef ARSEIG_H
 #define ARSEIG_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arerror.h"
 #include "arrseig.h"
@@ -58,7 +58,7 @@ class ARStdEig: virtual public ARrcStdEi
  // d.1) Function that stores user defined parameters.
 
   virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
-                                TypeOPx MultOPxp, char* whichp="LM",
+                                TypeOPx MultOPxp, const char* whichp="LM",
                                 int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                 ARTYPE* residp=NULL, bool ishiftp=true);
   // Set values of problem parameters (also called by constructors).
@@ -72,7 +72,7 @@ class ARStdEig: virtual public ARrcStdEi
   virtual void SetRegularMode(ARFOP* objOPp, TypeOPx MultOPxp);
   // Turns problem to regular mode.
 
-  virtual void SetShiftInvertMode(ARTYPE sigmap, ARFOP* objOPp, 
+  virtual void SetShiftInvertMode(ARTYPE sigmap, ARFOP* objOPp,
                                   TypeOPx MultOPxp);
   // Turns problem to shift and invert mode with shift defined by sigmap.
 
@@ -130,8 +130,8 @@ Copy(const ARStdEig<ARFLOAT, ARTYPE, ARF
 template<class ARFLOAT, class ARTYPE, class ARFOP>
 void ARStdEig<ARFLOAT, ARTYPE, ARFOP>::
 DefineParameters(int np, int nevp, ARFOP* objOPp,
-                 void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), char* whichp,
-                 int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
+                 void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), const char* whichp,
+                 int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp,
                  bool ishiftp)
 
 
@@ -152,7 +152,7 @@ ChangeMultOPx(ARFOP* objOPp, void (ARFOP
 
   objOP   = objOPp;
   MultOPx = MultOPxp;
-  Restart();
+  this->Restart();
 
 } // ChangeMultOPx.
 
@@ -163,19 +163,19 @@ SetRegularMode(ARFOP* objOPp, void (ARFO
 {
 
   ChangeMultOPx(objOPp, MultOPxp);
-  NoShift();
+  this->NoShift();
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT, class ARTYPE, class ARFOP>
 inline void ARStdEig<ARFLOAT, ARTYPE, ARFOP>::
-SetShiftInvertMode(ARTYPE sigmap, ARFOP* objOPp, 
+SetShiftInvertMode(ARTYPE sigmap, ARFOP* objOPp,
                    void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]))
 {
 
   ChangeMultOPx(objOPp, MultOPxp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // SetShiftInvertMode.
 
@@ -184,37 +184,37 @@ template<class ARFLOAT, class ARTYPE, cl
 int ARStdEig<ARFLOAT, ARTYPE, ARFOP>::FindArnoldiBasis()
 {
 
-  if (!BasisOK) Restart();
+  if (!this->BasisOK) this->Restart();
 
   // Changing to auto shift mode.
 
-  if (!AutoShift) {
+  if (!this->AutoShift) {
     ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-    AutoShift=true;
+    this->AutoShift=true;
   }
 
   // ARPACK main loop.
 
-  while (!BasisOK) {
+  while (!this->BasisOK) {
 
     // Calling Aupp.
 
-    try { TakeStep(); }
+    try { this->TakeStep(); }
     catch (ArpackError) {
       ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
       return 0;
     }
 
-    if ((ido == -1) || (ido == 1)) {
+    if ((this->ido == -1) || (this->ido == 1)) {
 
       // Performing Matrix vector multiplication: y <- OP*x.
 
-      (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      (objOP->*MultOPx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
     }
 
   }
-  return nconv;
+  return this->nconv;
 
 } // FindArnoldiBasis.
 
@@ -225,7 +225,7 @@ operator=(const ARStdEig<ARFLOAT, ARTYPE
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arsnsym.h /usr/local/include/arpack++/arsnsym.h
--- arpack++/include/arsnsym.h	2000-02-21 17:36:14.000000000 +0530
+++ /usr/local/include/arpack++/arsnsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARSNSYM_H
 #define ARSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrsnsym.h"
@@ -37,13 +38,13 @@ class ARNonSymStdEig:
 
   ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                  void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-                 char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+                 const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                  void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-                 ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+                 ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                  bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -71,13 +72,13 @@ template<class ARFLOAT, class ARFOP>
 inline ARNonSymStdEig<ARFLOAT, ARFOP>::
 ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-               char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
+               const char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -87,13 +88,13 @@ template<class ARFLOAT, class ARFOP>
 inline ARNonSymStdEig<ARFLOAT, ARFOP>::
 ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+               ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
@@ -105,7 +106,7 @@ operator=(const ARNonSymStdEig<ARFLOAT,
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -114,4 +115,3 @@ operator=(const ARNonSymStdEig<ARFLOAT,
 
 
 #endif // ARSNSYM_H
-
diff -rupN arpack++/include/arssym.h /usr/local/include/arpack++/arssym.h
--- arpack++/include/arssym.h	2000-02-21 17:35:00.000000000 +0530
+++ /usr/local/include/arpack++/arssym.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef ARSSYM_H
 #define ARSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrssym.h"
@@ -37,13 +38,13 @@ class ARSymStdEig:
 
   ARSymStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-              char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
+              const char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
               int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
   ARSymStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-              ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
+              ARFLOAT sigmap, const char* whichp = "LM", int ncvp = 0,
               ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
               bool ishiftp = true);
   // Long constructor (shift and invert mode).
@@ -71,13 +72,13 @@ template<class ARFLOAT, class ARFOP>
 inline ARSymStdEig<ARFLOAT, ARFOP>::
 ARSymStdEig(int np, int nevp, ARFOP* objOPp,
             void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-            char* whichp, int ncvp, ARFLOAT tolp,
+            const char* whichp, int ncvp, ARFLOAT tolp,
             int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->NoShift();
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -87,13 +88,13 @@ template<class ARFLOAT, class ARFOP>
 inline ARSymStdEig<ARFLOAT, ARFOP>::
 ARSymStdEig(int np, int nevp, ARFOP* objOPp,
             void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
-            ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+            ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
             int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  ChangeShift(sigmap);
-  DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
+  this->ChangeShift(sigmap);
+  this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (shift and invert mode).
@@ -105,7 +106,7 @@ operator=(const ARSymStdEig<ARFLOAT, ARF
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arugcomp.h /usr/local/include/arpack++/arugcomp.h
--- arpack++/include/arugcomp.h	2000-02-21 23:16:32.000000000 +0530
+++ /usr/local/include/arpack++/arugcomp.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUGComp.h.
-   Arpack++ class ARluCompGenEig definition
+   Arpack++ class ARumCompGenEig definition
    (umfpack version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARUGCOMP_H
 #define ARUGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arunsmat.h"
 #include "arunspen.h"
@@ -27,7 +28,7 @@
 
 
 template<class ARFLOAT>
-class ARluCompGenEig:
+class ARumCompGenEig:
   public virtual
     ARCompGenEig<ARFLOAT, ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                  ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > > {
@@ -40,7 +41,7 @@ class ARluCompGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluCompGenEig& other);
+  virtual void Copy(const ARumCompGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -60,68 +61,68 @@ class ARluCompGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluCompGenEig() { }
+  ARumCompGenEig() { }
   // Short constructor.
 
-  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARumCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 char* whichp = "LM", int ncvp = 0,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+  ARumCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                  ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }
+  ARumCompGenEig(const ARumCompGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompGenEig() { }
+  virtual ~ARumCompGenEig() { }
 
  // d) Operators.
 
-  ARluCompGenEig& operator=(const ARluCompGenEig& other);
+  ARumCompGenEig& operator=(const ARumCompGenEig& other);
   // Assignment operator.
 
-}; // class ARluCompGenEig.
+}; // class ARumCompGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompGenEig member functions definition.                              //
+// ARumCompGenEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
-Copy(const ARluCompGenEig<ARFLOAT>& other)
+inline void ARumCompGenEig<ARFLOAT>::
+Copy(const ARumCompGenEig<ARFLOAT>& other)
 {
 
   ARCompGenEig<ARFLOAT, ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARumCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()
+inline void ARumCompGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
@@ -133,7 +134,7 @@ inline void ARluCompGenEig<ARFLOAT>::Set
 
 
 template<class ARFLOAT>
-inline void ARluCompGenEig<ARFLOAT>::
+inline void ARumCompGenEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
@@ -146,19 +147,19 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
+inline ARumCompGenEig<ARFLOAT>::
+ARumCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp,
                arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
-                   &Pencil, 
+                   &Pencil,
                    &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -166,19 +167,19 @@ ARluCompGenEig(int nevp, ARumNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompGenEig<ARFLOAT>::
-ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+inline ARumCompGenEig<ARFLOAT>::
+ARumCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
-                   &Pencil, 
+                   &Pencil,
                    &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
   SetShiftInvertMode(sigmap);
@@ -187,12 +188,12 @@ ARluCompGenEig(int nevp, ARumNonSymMatri
 
 
 template<class ARFLOAT>
-ARluCompGenEig<ARFLOAT>& ARluCompGenEig<ARFLOAT>::
-operator=(const ARluCompGenEig<ARFLOAT>& other)
+ARumCompGenEig<ARFLOAT>& ARumCompGenEig<ARFLOAT>::
+operator=(const ARumCompGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arugnsym.h /usr/local/include/arpack++/arugnsym.h
--- arpack++/include/arugnsym.h	2000-02-21 23:12:32.000000000 +0530
+++ /usr/local/include/arpack++/arugnsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUGNSym.h.
-   Arpack++ class ARluNonSymGenEig definition
+   Arpack++ class ARumNonSymGenEig definition
    (umfpack version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARUGNSYM_H
 #define ARUGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arunsmat.h"
 #include "arunspen.h"
@@ -26,7 +27,7 @@
 
 
 template<class ARFLOAT>
-class ARluNonSymGenEig:
+class ARumNonSymGenEig:
   public virtual ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                                 ARumNonSymPencil<ARFLOAT, ARFLOAT> > {
 
@@ -38,7 +39,7 @@ class ARluNonSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluNonSymGenEig& other);
+  virtual void Copy(const ARumNonSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -56,78 +57,78 @@ class ARluNonSymGenEig:
 
   virtual void SetShiftInvertMode(ARFLOAT sigmap);
 
-  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp, 
+  virtual void SetComplexShiftMode(char partp, ARFLOAT sigmaRp,
                                    ARFLOAT sigmaIp);
 
  // c.2) Constructors and destructor.
 
-  ARluNonSymGenEig() { }
+  ARumNonSymGenEig() { }
   // Short constructor.
 
-  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
+  ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
-                   char* whichp = "LM", int ncvp = 0,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (real shift and invert mode).
 
-  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+  ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                    ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
-                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
+                   ARFLOAT sigmaRp, ARFLOAT sigmaIp, const char* whichp = "LM",
                    int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (complex shift and invert mode).
 
-  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }
+  ARumNonSymGenEig(const ARumNonSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymGenEig() { }
+  virtual ~ARumNonSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluNonSymGenEig& operator=(const ARluNonSymGenEig& other);
+  ARumNonSymGenEig& operator=(const ARumNonSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymGenEig.
+}; // class ARumNonSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymGenEig member functions definition.                            //
+// ARumNonSymGenEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
-Copy(const ARluNonSymGenEig<ARFLOAT>& other)
+inline void ARumNonSymGenEig<ARFLOAT>::
+Copy(const ARumNonSymGenEig<ARFLOAT>& other)
 {
 
   ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARumNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARumNonSymGenEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -135,7 +136,7 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARumNonSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT> >::
@@ -145,7 +146,7 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARumNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
@@ -157,30 +158,30 @@ inline void ARluNonSymGenEig<ARFLOAT>::S
 
 
 template<class ARFLOAT>
-inline void ARluNonSymGenEig<ARFLOAT>::
+inline void ARumNonSymGenEig<ARFLOAT>::
 SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
   ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARumNonSymPencil<ARFLOAT, ARFLOAT> >::
-    SetComplexShiftMode(partp, sigmaRp, sigmaIp, &Pencil, 
-                        &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, 
+    SetComplexShiftMode(partp, sigmaRp, sigmaIp, &Pencil,
+                        &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv,
                         &Pencil, &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultAv);
 
 } // SetComplexShiftMode.
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
+inline ARumNonSymGenEig<ARFLOAT>::
+ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, const char* whichp, int ncvp,
                  ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -189,16 +190,16 @@ ARluNonSymGenEig(int nevp, ARumNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+inline ARumNonSymGenEig<ARFLOAT>::
+ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                  ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -208,17 +209,17 @@ ARluNonSymGenEig(int nevp, ARumNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymGenEig<ARFLOAT>::
-ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
+inline ARumNonSymGenEig<ARFLOAT>::
+ARumNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B,
                  char partp, ARFLOAT sigmaRp,
-                 ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
+                 ARFLOAT sigmaIp, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -228,12 +229,12 @@ ARluNonSymGenEig(int nevp, ARumNonSymMat
 
 
 template<class ARFLOAT>
-ARluNonSymGenEig<ARFLOAT>& ARluNonSymGenEig<ARFLOAT>::
-operator=(const ARluNonSymGenEig<ARFLOAT>& other)
+ARumNonSymGenEig<ARFLOAT>& ARumNonSymGenEig<ARFLOAT>::
+operator=(const ARumNonSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arugsym.h /usr/local/include/arpack++/arugsym.h
--- arpack++/include/arugsym.h	2000-02-21 22:30:41.000000000 +0530
+++ /usr/local/include/arpack++/arugsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUGSym.h.
-   Arpack++ class ARluSymGenEig definition
+   Arpack++ class ARumSymGenEig definition
    (UMFPACK version).
 
    ARPACK Authors
@@ -19,7 +19,8 @@
 #ifndef ARUGSYM_H
 #define ARUGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arusmat.h"
 #include "aruspen.h"
@@ -27,7 +28,7 @@
 
 
 template<class ARFLOAT>
-class ARluSymGenEig:
+class ARumSymGenEig:
   public virtual ARSymGenEig<ARFLOAT, ARumSymPencil<ARFLOAT>,
                              ARumSymPencil<ARFLOAT> > {
 
@@ -39,7 +40,7 @@ class ARluSymGenEig:
 
  // b) Protected functions:
 
-  virtual void Copy(const ARluSymGenEig& other);
+  virtual void Copy(const ARumSymGenEig& other);
   // Makes a deep copy of "other" over "this" object.
   // Old values are not deleted (this function is to be used
   // by the copy constructor and the assignment operator only).
@@ -63,67 +64,67 @@ class ARluSymGenEig:
 
  // c.2) Constructors and destructor.
 
-  ARluSymGenEig() { }
+  ARumSymGenEig() { }
   // Short constructor.
 
-  ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-                ARumSymMatrix<ARFLOAT>& B, char* whichp = "LM",
+  ARumSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+                ARumSymMatrix<ARFLOAT>& B, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
-                ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
+  ARumSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
+                ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert, buckling and Cayley modes).
 
-  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }
+  ARumSymGenEig(const ARumSymGenEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymGenEig() { }
+  virtual ~ARumSymGenEig() { }
   // Destructor.
 
  // d) Operators.
 
-  ARluSymGenEig& operator=(const ARluSymGenEig& other);
+  ARumSymGenEig& operator=(const ARumSymGenEig& other);
   // Assignment operator.
 
-}; // class ARluSymGenEig.
+}; // class ARumSymGenEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymGenEig member functions definition.                               //
+// ARumSymGenEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
-Copy(const ARluSymGenEig<ARFLOAT>& other)
+inline void ARumSymGenEig<ARFLOAT>::
+Copy(const ARumSymGenEig<ARFLOAT>& other)
 {
 
   ARSymGenEig<ARFLOAT, ARumSymPencil<ARFLOAT>,
               ARumSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
+inline void ARumSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()
+inline void ARumSymGenEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumSymPencil<ARFLOAT> >::
@@ -133,7 +134,7 @@ inline void ARluSymGenEig<ARFLOAT>::SetR
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARumSymGenEig<ARFLOAT>::
 SetShiftInvertMode(ARFLOAT sigmap)
 {
 
@@ -145,7 +146,7 @@ SetShiftInvertMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARumSymGenEig<ARFLOAT>::
 SetBucklingMode(ARFLOAT sigmap)
 {
 
@@ -157,7 +158,7 @@ SetBucklingMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline void ARluSymGenEig<ARFLOAT>::
+inline void ARumSymGenEig<ARFLOAT>::
 SetCayleyMode(ARFLOAT sigmap)
 {
 
@@ -170,17 +171,17 @@ SetCayleyMode(ARFLOAT sigmap)
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-              ARumSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
+inline ARumSymGenEig<ARFLOAT>::
+ARumSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+              ARumSymMatrix<ARFLOAT>& B, const char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->InvertMode = 'S';
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
@@ -189,26 +190,26 @@ ARluSymGenEig(int nevp, ARumSymMatrix<AR
 
 
 template<class ARFLOAT>
-inline ARluSymGenEig<ARFLOAT>::
-ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
+inline ARumSymGenEig<ARFLOAT>::
+ARumSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
               ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
-              char* whichp, int ncvp, ARFLOAT tolp,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
   Pencil.DefineMatrices(A, B);
-  DefineParameters(A.ncols(), nevp, &Pencil,
+  this->DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':  // Buckling mode.
     ChangeMultBx(&Pencil, &ARumSymPencil<ARFLOAT>::MultAv);
   case 'S':  // Shift and invert mode.
-    ChangeShift(sigmap);
-    break;  
+    this->ChangeShift(sigmap);
+    break;
   case 'C':  // Cayley mode.
     SetCayleyMode(sigmap);
   }
@@ -217,12 +218,12 @@ ARluSymGenEig(char InvertModep, int nevp
 
 
 template<class ARFLOAT>
-ARluSymGenEig<ARFLOAT>& ARluSymGenEig<ARFLOAT>::
-operator=(const ARluSymGenEig<ARFLOAT>& other)
+ARumSymGenEig<ARFLOAT>& ARumSymGenEig<ARFLOAT>::
+operator=(const ARumSymGenEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+   this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arunsmat.h /usr/local/include/arpack++/arunsmat.h
--- arpack++/include/arunsmat.h	2000-02-21 22:12:41.000000000 +0530
+++ /usr/local/include/arpack++/arunsmat.h	2016-11-17 18:22:42.136889211 +0530
@@ -20,7 +20,8 @@
 #ifndef ARUNSMAT_H
 #define ARUNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -145,19 +146,19 @@ bool ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
-      if ((irow[j]<0)||(irow[k]>=n)) return false;
+      if ((irow[j]<0)||(irow[k]>=this->n)) return false;
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
-    }  
+    }
   }
 
   return true;
@@ -190,9 +191,9 @@ Copy(const ARumNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   fillin    = other.fillin;
   nnz       = other.nnz;
@@ -205,7 +206,7 @@ Copy(const ARumNonSymMatrix<ARTYPE, ARFL
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying arrays with static dimension.
 
@@ -224,7 +225,7 @@ Copy(const ARumNonSymMatrix<ARTYPE, ARFL
 
   for (i=0; i<lindex; i++) index[i] = other.index[i];
   copy(lvalue, other.value, 1, value, 1);
-  
+
 } // Copy.
 
 
@@ -237,10 +238,10 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   // Subtracting sigma from diagonal elements.
 
   k        = 0;
-  ki       = n+1;
+  ki       = this->n+1;
   index[0] = 1;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
 
     j = pcol[i];
     end = pcol[i+1];
@@ -280,11 +281,11 @@ template<class ARTYPE, class ARFLOAT>
 inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()
 {
 
-  int dimfact = (((fillin+1)*nnz)<(n*n)) ? (fillin+1)*nnz : n*n;
+  int dimfact = (((fillin+1)*nnz)<(this->n*this->n)) ? (fillin+1)*nnz : this->n*this->n;
 
-  ClearMem();
+  this->ClearMem();
 
-  lindex = 30*n+dimfact;     // ?????
+  lindex = 30*this->n+dimfact;     // ?????
   lvalue = dimfact;
 
   value  = new ARTYPE[lvalue];
@@ -319,13 +320,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::FactorA");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARumNonSymMatrix::FactorA");
   }
@@ -344,13 +345,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   copy(nnz, a, 1, value, 1);
   pi=pcol;
   pj=index;
-  for (i=0; i<=n; i++) *pj++ = (*pi++)+1;
+  for (i=0; i<=this->n; i++) *pj++ = (*pi++)+1;
   pi=irow;
   for (i=0; i<nnz; i++) *pj++ = (*pi++)+1;
 
   // Decomposing A.
 
-  um2fa(n, nnz, 0, false, lvalue, lindex, value, 
+  um2fa(this->n, nnz, 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -368,14 +369,14 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARumNonSymMatrix::FactorAsI");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARumNonSymMatrix::FactorAsI");
   }
@@ -390,7 +391,7 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing AsI.
 
-  um2fa(n, nnz, 0, false, lvalue, lindex, value,
+  um2fa(this->n, nnz, 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -411,15 +412,15 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = v[i];
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       w[irow[j]] += t*a[j];
@@ -438,13 +439,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = (ARTYPE)0;
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       t += v[irow[j]]*a[j];
@@ -459,7 +460,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -473,7 +474,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -487,8 +488,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -506,9 +507,9 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Solving A.w = v (or AsI.w = v).
 
-  ARTYPE* space = new ARTYPE[2*n];
+  ARTYPE* space = new ARTYPE[2*this->n];
 
-  um2so(n, 0, false, lvalue, lindex, value, index,
+  um2so(this->n, 0, false, lvalue, lindex, value, index,
         keep, v, w, space, cntl, icntl, info, rinfo);
 
   delete[] space;
@@ -525,13 +526,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   fillin    = (fillinp>2) ? fillinp : 2;
   threshold = thresholdp;
   value     = NULL;
@@ -548,7 +549,7 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
                       "ARumNonSymMatrix::DefineMatrix");
   }
   else {
-    defined = true;
+    this->defined = true;
   }
 
 } // DefineMatrix (square).
@@ -561,15 +562,15 @@ DefineMatrix(int mp, int np, int nnzp, A
 
   // Defining member variables.
 
-  m        = mp;
-  n        = np;
+  this->m        = mp;
+  this->n        = np;
   nnz      = nnzp;
   a        = ap;
   irow     = irowp;
   pcol     = pcolp;
-  pcol[n]  = nnz;
+  pcol[this->n]  = nnz;
   fillin   = 0;
-  defined  = true;
+  this->defined  = true;
 
 } // DefineMatrix (rectangular).
 
@@ -582,7 +583,7 @@ ARumNonSymMatrix(int np, int nnzp, ARTYP
 {
 
   factored = false;
-  DefineMatrix(np, nnzp, ap, irowp, pcolp, thresholdp,
+  this->DefineMatrix(np, nnzp, ap, irowp, pcolp, thresholdp,
                fillinp, simest, reducible, check);
 
 } // Long constructor (square matrix).
@@ -595,7 +596,7 @@ ARumNonSymMatrix(int mp, int np, int nnz
 {
 
   factored = false;
-  DefineMatrix(mp, np, nnzp, ap, irowp, pcolp);
+  this->DefineMatrix(mp, np, nnzp, ap, irowp, pcolp);
 
 } // Long constructor (rectangular matrix).
 
@@ -616,12 +617,12 @@ ARumNonSymMatrix(char* name, double thre
   }
 
   if (mat.NCols()==mat.NRows()) {
-    DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
+    this->DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
                  mat.RowInd(), mat.ColPtr(), thresholdp,
                  fillinp, simest, reducible, check);
   }
   else {
-    DefineMatrix(mat.NRows(), mat.NCols(), mat.NonZeros(),
+    this->DefineMatrix(mat.NRows(), mat.NCols(), mat.NonZeros(),
                  (ARTYPE*)mat.Entries(), mat.RowInd(), mat.ColPtr());
   }
 
diff -rupN arpack++/include/arunspen.h /usr/local/include/arpack++/arunspen.h
--- arpack++/include/arunspen.h	2000-02-21 22:21:12.000000000 +0530
+++ /usr/local/include/arpack++/arunspen.h	2016-11-17 18:22:42.136889211 +0530
@@ -83,13 +83,13 @@ class ARumNonSymPencil
 
   void MultInvAsBv(ARFLOAT* v, ARFLOAT* w);
 
-  void DefineMatrices(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  void DefineMatrices(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                       ARumNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
 
   ARumNonSymPencil() { part = 'N'; }
   // Short constructor that does nothing.
 
-  ARumNonSymPencil(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+  ARumNonSymPencil(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                    ARumNonSymMatrix<ARTYPE, ARFLOAT>& Bp);
   // Long constructor.
 
@@ -183,7 +183,7 @@ SparseSaxpy(ARTYPE a, ARTYPE x[], int xi
 template<class ARTYPE, class ARFLOAT>
 void ARumNonSymPencil<ARTYPE, ARFLOAT>::
 SparseSaxpy(arcomplex<ARFLOAT> a, ARFLOAT x[], int xind[], int nx,
-            ARFLOAT y[], int yind[], int ny, 
+            ARFLOAT y[], int yind[], int ny,
             arcomplex<ARFLOAT> z[], int zind[], int& nz)
 // A strongly sequential (and inefficient) sparse saxpy algorithm.
 {
@@ -260,7 +260,7 @@ void ARumNonSymPencil<ARTYPE, ARFLOAT>::
     AsB.index[i+1] = asbcol;
   }
 
-  AsB.nnz = asbcol; 
+  AsB.nnz = asbcol;
 
   // Adding one to all elements of vector index
   // because the decomposition function was written in FORTRAN.
@@ -329,9 +329,9 @@ void ARumNonSymPencil<ARTYPE, ARFLOAT>::
   if (!AsB.IsDefined()) {
 
     int fillin = A->fillin > B->fillin ? A->fillin : B->fillin;
-    AsB.DefineMatrix(A->ncols(), A->nzeros(), A->a, A->irow, 
-                     A->pcol, A->threshold, fillin, 
-                     (A->IsSymmetric() && B->IsSymmetric()), 
+    AsB.DefineMatrix(A->ncols(), A->nzeros(), A->a, A->irow,
+                     A->pcol, A->threshold, fillin,
+                     (A->IsSymmetric() && B->IsSymmetric()),
                      A->icntl[3], false);
     AsB.nnz = A->nzeros()+B->nzeros(); // temporary value.
 
@@ -386,8 +386,8 @@ FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI
     part        = partp;
     int  fillin = A->fillin > B->fillin ? A->fillin : B->fillin;
     AsBc.DefineMatrix(A->ncols(), A->nzeros(), 0, 0,
-                      A->pcol, A->threshold, fillin, 
-                      (A->IsSymmetric() && B->IsSymmetric()), 
+                      A->pcol, A->threshold, fillin,
+                      (A->IsSymmetric() && B->IsSymmetric()),
                       A->icntl[3], false);
     AsBc.nnz    = A->nzeros()+B->nzeros(); // temporary value.
 
@@ -404,7 +404,7 @@ FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI
   // Decomposing AsB.
 
   um2fa(AsBc.n, AsBc.index[AsBc.n], 0, false, AsBc.lvalue, AsBc.lindex,
-        AsBc.value, AsBc.index, AsBc.keep, AsBc.cntl, AsBc.icntl, 
+        AsBc.value, AsBc.index, AsBc.keep, AsBc.cntl, AsBc.icntl,
         AsBc.info, AsBc.rinfo);
 
   // Handling errors.
@@ -485,7 +485,7 @@ void ARumNonSymPencil<ARTYPE, ARFLOAT>::
 
 template<class ARTYPE, class ARFLOAT>
 inline void ARumNonSymPencil<ARTYPE, ARFLOAT>::
-DefineMatrices(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+DefineMatrices(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                ARumNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
@@ -502,11 +502,11 @@ DefineMatrices(ARumNonSymMatrix<ARTYPE,
 
 template<class ARTYPE, class ARFLOAT>
 inline ARumNonSymPencil<ARTYPE, ARFLOAT>::
-ARumNonSymPencil(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, 
+ARumNonSymPencil(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap,
                  ARumNonSymMatrix<ARTYPE, ARFLOAT>& Bp)
 {
 
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/aruscomp.h /usr/local/include/arpack++/aruscomp.h
--- arpack++/include/aruscomp.h	2000-02-21 23:08:55.000000000 +0530
+++ /usr/local/include/arpack++/aruscomp.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUSComp.h.
-   Arpack++ class ARluCompStdEig definition
+   Arpack++ class ARumCompStdEig definition
    (umfpack version).
 
    ARPACK Authors
@@ -18,7 +18,8 @@
 #ifndef ARUSCOMP_H
 #define ARUSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "arunsmat.h"
@@ -26,8 +27,8 @@
 
 
 template<class ARFLOAT>
-class ARluCompStdEig:
-  public virtual ARCompStdEig<ARFLOAT, 
+class ARumCompStdEig:
+  public virtual ARCompStdEig<ARFLOAT,
                               ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> > {
 
  public:
@@ -44,87 +45,87 @@ class ARluCompStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluCompStdEig() { }
+  ARumCompStdEig() { }
   // Short constructor.
 
-  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
-                 char* whichp = "LM", int ncvp = 0,
+  ARumCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 const char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-                 arcomplex<ARFLOAT> sigma, char* whichp = "LM",
+  ARumCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+                 arcomplex<ARFLOAT> sigma, const char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }
+  ARumCompStdEig(const ARumCompStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluCompStdEig() { }
+  virtual ~ARumCompStdEig() { }
   // Destructor.
 
 
  // b) Operators.
 
-  ARluCompStdEig& operator=(const ARluCompStdEig& other);
+  ARumCompStdEig& operator=(const ARumCompStdEig& other);
   // Assignment operator.
 
-}; // class ARluCompStdEig.
+}; // class ARumCompStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluCompStdEig member functions definition.                              //
+// ARumCompStdEig member functions definition.                              //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARumCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()
+inline void ARumCompStdEig<ARFLOAT>::SetRegularMode()
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP,
                    &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluCompStdEig<ARFLOAT>::
+inline void ARumCompStdEig<ARFLOAT>::
 SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)
 {
 
-  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
+  ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARumNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               char* whichp, int ncvp, ARFLOAT tolp,
+inline ARumCompStdEig<ARFLOAT>::
+ARumCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               const char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -132,29 +133,29 @@ ARluCompStdEig(int nevp, ARumNonSymMatri
 
 
 template<class ARFLOAT>
-inline ARluCompStdEig<ARFLOAT>::
-ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
-               arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
+inline ARumCompStdEig<ARFLOAT>::
+ARumCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
+               arcomplex<ARFLOAT> sigmap, const char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluCompStdEig<ARFLOAT>& ARluCompStdEig<ARFLOAT>::
-operator=(const ARluCompStdEig<ARFLOAT>& other)
+ARumCompStdEig<ARFLOAT>& ARumCompStdEig<ARFLOAT>::
+operator=(const ARumCompStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/arusmat.h /usr/local/include/arpack++/arusmat.h
--- arpack++/include/arusmat.h	2000-02-21 22:23:51.000000000 +0530
+++ /usr/local/include/arpack++/arusmat.h	2016-11-17 18:22:42.136889211 +0530
@@ -20,7 +20,8 @@
 #ifndef ARUSMAT_H
 #define ARUSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -85,7 +86,7 @@ class ARumSymMatrix: public ARMatrix<ART
   void MultInvv(ARTYPE* v, ARTYPE* w);
 
   void DefineMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,
-                    int* pcolp, char uplop = 'L', double thresholdp = 0.1, 
+                    int* pcolp, char uplop = 'L', double thresholdp = 0.1,
                     int fillinp = 9, bool reducible = true, bool check = true);
 
   ARumSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }
@@ -125,12 +126,12 @@ bool ARumSymMatrix<ARTYPE>::DataOK()
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
@@ -138,13 +139,13 @@ bool ARumSymMatrix<ARTYPE>::DataOK()
         if ((irow[j]<0)||(irow[k]>i)) return false;
       }
       else { // uplo == 'L'.
-        if ((irow[j]<i)||(irow[k]>=n)) return false;
+        if ((irow[j]<i)||(irow[k]>=this->n)) return false;
       }
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
     }
   }
-  
+
   return true;
 
 } // DataOK.
@@ -174,9 +175,9 @@ void ARumSymMatrix<ARTYPE>::Copy(const A
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   fillin    = other.fillin;
   nnz       = other.nnz;
@@ -190,7 +191,7 @@ void ARumSymMatrix<ARTYPE>::Copy(const A
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying arrays with static dimension.
 
@@ -226,13 +227,13 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
 
   // Filling index with zeros.
 
-  for (i=0; i<=n; i++) index[i] = 0;
+  for (i=0; i<=this->n; i++) index[i] = 0;
 
   // Counting the elements in each column of A.
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
         k--;
@@ -240,13 +241,13 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
       else {
         if (subtract) index[i]++;
       }
-      for (j=pcol[i]; j<k; j++) index[irow[j]]++;        
+      for (j=pcol[i]; j<k; j++) index[irow[j]]++;
     }
 
   }
   else { // uplo == 'L'
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
         k++;
@@ -254,30 +255,30 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
       else {
         if (subtract) index[i]++;
       }
-      for (j=k; j<pcol[i+1]; j++) index[irow[j]]++;        
+      for (j=k; j<pcol[i+1]; j++) index[irow[j]]++;
     }
 
-  }  
+  }
 
   // Summing up index elements.
 
-  for (i=0; i<n; i++) index[i+1]+=index[i];
+  for (i=0; i<this->n; i++) index[i+1]+=index[i];
 
   // Adding pcol to index.
 
-  for (i=n; i>0; i--) index[i] = index[i-1]+pcol[i];
-  index[0] = pcol[0];    
+  for (i=this->n; i>0; i--) index[i] = index[i-1]+pcol[i];
+  index[0] = pcol[0];
 
   // Expanding A.
 
-  ki = n+1;
+  ki = this->n+1;
 
   if (uplo == 'U') {
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       for (j=pcol[i]; j<(pcol[i+1]-1); j++) {
         index[ki+index[i]] = irow[j]+1;
-        index[ki+index[irow[j]]] = i+1; 
+        index[ki+index[irow[j]]] = i+1;
         value[index[i]++] = a[j];
         value[index[irow[j]]++] = a[j];
       }
@@ -301,7 +302,7 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
   }
   else { // uplo  == 'L'
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       k=pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
         index[ki+index[i]] = i+1;
@@ -321,7 +322,7 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
       }
       for (j=k; j<pcol[i+1]; j++) {
         index[ki+index[i]] = irow[j]+1;
-        index[ki+index[irow[j]]] = i+1; 
+        index[ki+index[irow[j]]] = i+1;
         value[index[i]++] = a[j];
         value[index[irow[j]]++] = a[j];
       }
@@ -331,9 +332,9 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
 
   // Adjusting index.
 
-  for (i=n; i>0; i--) {
+  for (i=this->n; i>0; i--) {
     index[i] = index[i-1]+1;
-  } 
+  }
   index[0] = 1;
 
 } // ExpandA.
@@ -343,11 +344,11 @@ template<class ARTYPE>
 inline void ARumSymMatrix<ARTYPE>::CreateStructure()
 {
 
-  int dimfact = (((fillin+1)*nnz*2)<(n*n)) ? (fillin+1)*nnz*2 : n*n;
+  int dimfact = (((fillin+1)*nnz*2)<(this->n*this->n)) ? (fillin+1)*nnz*2 : this->n*this->n;
 
   ClearMem();
 
-  lindex = 30*n+dimfact;          // ?????
+  lindex = 30*this->n+dimfact;          // ?????
   lvalue = dimfact;
 
   value  = new ARTYPE[lvalue];
@@ -382,7 +383,7 @@ void ARumSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorA");
   }
 
@@ -396,7 +397,7 @@ void ARumSymMatrix<ARTYPE>::FactorA()
 
   // Decomposing A.
 
-  um2fa(n, index[n], 0, false, lvalue, lindex, value, 
+  um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -414,7 +415,7 @@ void ARumSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorAsI");
   }
 
@@ -428,7 +429,7 @@ void ARumSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  um2fa(n, index[n], 0, false, lvalue, lindex, value,
+  um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -449,17 +450,17 @@ void ARumSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
@@ -475,7 +476,7 @@ void ARumSymMatrix<ARTYPE>::MultMv(ARTYP
   }
   else {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
@@ -506,9 +507,9 @@ void ARumSymMatrix<ARTYPE>::MultInvv(ART
 
   // Solving A.w = v (or AsI.w = v).
 
-  ARTYPE* space = new ARTYPE[2*n];
+  ARTYPE* space = new ARTYPE[2*this->n];
 
-  um2so(n, 0, false, lvalue, lindex, value, index,
+  um2so(this->n, 0, false, lvalue, lindex, value, index,
         keep, v, w, space, cntl, icntl, info, rinfo);
 
   delete[] space;
@@ -525,13 +526,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   uplo      = uplop;
   fillin    = (fillinp>2) ? fillinp : 2;
   threshold = thresholdp;
@@ -549,7 +550,7 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
                       "ARumSymMatrix::DefineMatrix");
   }
   else {
-    defined = true;
+    this->defined = true;
   }
 
 } // DefineMatrix.
@@ -563,7 +564,7 @@ ARumSymMatrix(int np, int nnzp, ARTYPE*
 {
 
   factored = false;
-  DefineMatrix(np, nnzp, ap, irowp, pcolp, uplop,
+  this->DefineMatrix(np, nnzp, ap, irowp, pcolp, uplop,
                thresholdp, fillinp, reducible, check);
 
 } // Long constructor.
@@ -586,7 +587,7 @@ ARumSymMatrix(char* file, double thresho
 
   if ((mat.NCols() == mat.NRows()) && (mat.IsSymmetric())) {
 
-    DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
+    this->DefineMatrix(mat.NCols(), mat.NonZeros(), (ARTYPE*)mat.Entries(),
                  mat.RowInd(), mat.ColPtr(), 'L', thresholdp,
                  fillinp, reducible, check);
   }
diff -rupN arpack++/include/arusnsym.h /usr/local/include/arpack++/arusnsym.h
--- arpack++/include/arusnsym.h	2000-02-21 23:05:24.000000000 +0530
+++ /usr/local/include/arpack++/arusnsym.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUSNSym.h.
-   Arpack++ class ARluNonSymStdEig definition
+   Arpack++ class ARumNonSymStdEig definition
    (umfpack version).
 
    ARPACK Authors
@@ -18,14 +18,15 @@
 #ifndef ARUSNSYM_H
 #define ARUSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "arunsmat.h"
 
 
 template<class ARFLOAT>
-class ARluNonSymStdEig:
+class ARumNonSymStdEig:
   public virtual ARNonSymStdEig<ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> > {
 
  public:
@@ -42,86 +43,86 @@ class ARluNonSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluNonSymStdEig() { }
+  ARumNonSymStdEig() { }
   // Short constructor.
 
-  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   char* whichp = "LM", int ncvp = 0,
+  ARumNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                   ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARumNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                   ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                    ARFLOAT tolp = 0.0, int maxitp = 0,
                    ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }
+  ARumNonSymStdEig(const ARumNonSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluNonSymStdEig() { }
+  virtual ~ARumNonSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluNonSymStdEig& operator=(const ARluNonSymStdEig& other);
+  ARumNonSymStdEig& operator=(const ARumNonSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluNonSymStdEig.
+}; // class ARumNonSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluNonSymStdEig member functions definition.                            //
+// ARumNonSymStdEig member functions definition.                            //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
+inline void ARumNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARumNonSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARumNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 char* whichp, int ncvp, ARFLOAT tolp,
+inline ARumNonSymStdEig<ARFLOAT>::
+ARumNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -129,28 +130,28 @@ ARluNonSymStdEig(int nevp, ARumNonSymMat
 
 
 template<class ARFLOAT>
-inline ARluNonSymStdEig<ARFLOAT>::
-ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
-                 ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARumNonSymStdEig<ARFLOAT>::
+ARumNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
+                 ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
                  int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, 
+  this->DefineParameters(A.ncols(), nevp, &A,
                    &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluNonSymStdEig<ARFLOAT>& ARluNonSymStdEig<ARFLOAT>::
-operator=(const ARluNonSymStdEig<ARFLOAT>& other)
+ARumNonSymStdEig<ARFLOAT>& ARumNonSymStdEig<ARFLOAT>::
+operator=(const ARumNonSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -159,4 +160,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARUSNSYM_H
-
diff -rupN arpack++/include/aruspen.h /usr/local/include/arpack++/aruspen.h
--- arpack++/include/aruspen.h	2000-02-21 22:25:50.000000000 +0530
+++ /usr/local/include/arpack++/aruspen.h	2016-11-17 18:22:42.136889211 +0530
@@ -172,7 +172,7 @@ void ARumSymPencil<ARTYPE>::ExpandAsB()
     for (i=0; i!=n; i++) {
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) k--;
-      for (j=pcol[i]; j<k; j++) pos[irow[j]]++;        
+      for (j=pcol[i]; j<k; j++) pos[irow[j]]++;
     }
 
   }
@@ -181,16 +181,16 @@ void ARumSymPencil<ARTYPE>::ExpandAsB()
     for (i=0; i!=n; i++) {
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) k++;
-      for (j=k; j<pcol[i+1]; j++) pos[irow[j]]++;        
+      for (j=k; j<pcol[i+1]; j++) pos[irow[j]]++;
     }
 
-  }  
+  }
 
   // Summing up index elements.
 
   for (i=0; i<n; i++) pos[i+1] += pos[i];
   for (i=n; i>0; i--) index[i] += pos[i-1];
-    
+
   // Expanding A.
 
   if (AsB.uplo == 'U') {
@@ -234,11 +234,11 @@ void ARumSymPencil<ARTYPE>::ExpandAsB()
 
   }
 
-  AsB.nnz = index[n]; 
+  AsB.nnz = index[n];
 
   //  Deleting temporary vectors.
 
-  delete[] pcol;  
+  delete[] pcol;
   delete[] pos;
 
 } // ExpandAsB.
@@ -307,7 +307,7 @@ void ARumSymPencil<ARTYPE>::FactorAsB(AR
 
   // Reserving memory for some vectors used in matrix decomposition.
 
-  AsB.CreateStructure(); 
+  AsB.CreateStructure();
 
   // Subtracting sigma*B from A and storing the result on AsB.
 
@@ -362,7 +362,7 @@ ARumSymPencil(ARumSymMatrix<ARTYPE>& Ap,
 {
 
   AsB.factored  = false;
-  DefineMatrices(Ap, Bp);
+  this->DefineMatrices(Ap, Bp);
 
 } // Long constructor.
 
diff -rupN arpack++/include/arussym.h /usr/local/include/arpack++/arussym.h
--- arpack++/include/arussym.h	2000-02-21 22:27:27.000000000 +0530
+++ /usr/local/include/arpack++/arussym.h	2016-11-17 18:22:42.136889211 +0530
@@ -3,7 +3,7 @@
    c++ interface to ARPACK code.
 
    MODULE ARUSSym.h.
-   Arpack++ class ARluSymStdEig definition
+   Arpack++ class ARumSymStdEig definition
    (UMFPACK version).
 
    ARPACK Authors
@@ -18,14 +18,15 @@
 #ifndef ARUSSYM_H
 #define ARUSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arusmat.h"
 
 
 template<class ARFLOAT>
-class ARluSymStdEig:
+class ARumSymStdEig:
   public virtual ARSymStdEig<ARFLOAT, ARumSymMatrix<ARFLOAT> > {
 
  public:
@@ -42,111 +43,111 @@ class ARluSymStdEig:
 
  // a.2) Constructors and destructor.
 
-  ARluSymStdEig() { }
+  ARumSymStdEig() { }
   // Short constructor.
 
-  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-                char* whichp = "LM", int ncvp = 0,
+  ARumSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+                const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (regular mode).
 
-  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-                ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
+  ARumSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+                ARFLOAT sigma, const char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 ARFLOAT* residp = NULL, bool ishiftp = true);
   // Long constructor (shift and invert mode).
 
-  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }
+  ARumSymStdEig(const ARumSymStdEig& other) { Copy(other); }
   // Copy constructor.
 
-  virtual ~ARluSymStdEig() { }
+  virtual ~ARumSymStdEig() { }
   // Destructor.
 
  // b) Operators.
 
-  ARluSymStdEig& operator=(const ARluSymStdEig& other);
+  ARumSymStdEig& operator=(const ARumSymStdEig& other);
   // Assignment operator.
 
-}; // class ARluSymStdEig.
+}; // class ARumSymStdEig.
 
 
 // ------------------------------------------------------------------------ //
-// ARluSymStdEig member functions definition.                               //
+// ARumSymStdEig member functions definition.                               //
 // ------------------------------------------------------------------------ //
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
+inline void ARumSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()
+inline void ARumSymStdEig<ARFLOAT>::SetRegularMode()
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
 
 template<class ARFLOAT>
-inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
+inline void ARumSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-              char* whichp, int ncvp, ARFLOAT tolp,
+inline ARumSymStdEig<ARFLOAT>::
+ARumSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+              const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
-  DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultMv,
+  this->NoShift();
+  this->DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
 
 
 template<class ARFLOAT>
-inline ARluSymStdEig<ARFLOAT>::
-ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
-              ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
+inline ARumSymStdEig<ARFLOAT>::
+ARumSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
+              ARFLOAT sigmap, const char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, ARFLOAT* residp, bool ishiftp)
 
 {
 
-  DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultInvv,
+  this->DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultInvv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
-  ChangeShift(sigmap);
+  this->ChangeShift(sigmap);
 
 } // Long constructor (shift and invert mode).
 
 
 template<class ARFLOAT>
-ARluSymStdEig<ARFLOAT>& ARluSymStdEig<ARFLOAT>::
-operator=(const ARluSymStdEig<ARFLOAT>& other)
+ARumSymStdEig<ARFLOAT>& ARumSymStdEig<ARFLOAT>::
+operator=(const ARumSymStdEig<ARFLOAT>& other)
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++/include/ceupp.h /usr/local/include/arpack++/ceupp.h
--- arpack++/include/ceupp.h	2000-02-21 17:24:11.000000000 +0530
+++ /usr/local/include/arpack++/ceupp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef CEUPP_H
 #define CEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++/include/neupp.h /usr/local/include/arpack++/neupp.h
--- arpack++/include/neupp.h	2000-02-21 17:21:10.000000000 +0530
+++ /usr/local/include/arpack++/neupp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef NEUPP_H
 #define NEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++/include/seupp.h /usr/local/include/arpack++/seupp.h
--- arpack++/include/seupp.h	2000-02-21 17:27:23.000000000 +0530
+++ /usr/local/include/arpack++/seupp.h	2016-11-17 18:22:42.136889211 +0530
@@ -17,7 +17,8 @@
 #ifndef SEUPP_H
 #define SEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++/include/umfpackf.h /usr/local/include/arpack++/umfpackf.h
--- arpack++/include/umfpackf.h	2000-02-21 17:09:40.000000000 +0530
+++ /usr/local/include/arpack++/umfpackf.h	2016-11-17 18:22:42.136889211 +0530
@@ -26,17 +26,17 @@ extern "C"
 
   void F77NAME(ums21i)(ARint *keep, float *cntl, ARint *icntl);
 
-  void F77NAME(ums2fa)(const ARint *n, const ARint *ne, 
+  void F77NAME(ums2fa)(const ARint *n, const ARint *ne,
                        const ARint *job, const ARlogical *transa,
                        const ARint *lvalue, const ARint *lindex,
                        float *value, ARint *index, ARint *keep,
                        const float *cntl, const ARint *icntl,
-                       ARint *info, float *rinfo); 
+                       ARint *info, float *rinfo);
 
   void F77NAME(ums2so)(const ARint *n, const ARint *job,
                        const ARlogical *transc, const ARint *lvalue,
                        const ARint *lindex, float *value,
-                       ARint *index, const ARint *keep, 
+                       ARint *index, const ARint *keep,
                        const float *b, float *x, float *w,
                        const float *cntl, const ARint *icntl,
                        ARint *info, float *rinfo);
@@ -46,17 +46,17 @@ extern "C"
 
   void F77NAME(umd21i)(ARint *keep, double *cntl, ARint *icntl);
 
-  void F77NAME(umd2fa)(const ARint *n, const ARint *ne, 
+  void F77NAME(umd2fa)(const ARint *n, const ARint *ne,
                        const ARint *job, const ARlogical *transa,
                        const ARint *lvalue, const ARint *lindex,
                        double *value, ARint *index, ARint *keep,
                        const double *cntl, const ARint *icntl,
-                       ARint *info, double *rinfo); 
+                       ARint *info, double *rinfo);
 
   void F77NAME(umd2so)(const ARint *n, const ARint *job,
                        const ARlogical *transc, const ARint *lvalue,
                        const ARint *lindex, double *value,
-                       ARint *index, const ARint *keep, 
+                       ARint *index, const ARint *keep,
                        const double *b, double *x, double *w,
                        const double *cntl, const ARint *icntl,
                        ARint *info, double *rinfo);
@@ -68,19 +68,19 @@ extern "C"
 
   void F77NAME(umc21i)(ARint *keep, float *cntl, ARint *icntl);
 
-  void F77NAME(umc2fa)(const ARint *n, const ARint *ne, 
+  void F77NAME(umc2fa)(const ARint *n, const ARint *ne,
                        const ARint *job, const ARlogical *transa,
                        const ARint *lvalue, const ARint *lindex,
                        arcomplex<float> *value, ARint *index, ARint *keep,
                        const float *cntl, const ARint *icntl,
-                       ARint *info, float *rinfo); 
+                       ARint *info, float *rinfo);
 
   void F77NAME(umc2so)(const ARint *n, const ARint *job,
                        const ARlogical *transc, const ARint *lvalue,
                        const ARint *lindex, arcomplex<float> *value,
-                       ARint *index, const ARint *keep, 
-                       const arcomplex<float> *b, arcomplex<float> *x, 
-                       arcomplex<float> *w, const float *cntl, 
+                       ARint *index, const ARint *keep,
+                       const arcomplex<float> *b, arcomplex<float> *x,
+                       arcomplex<float> *w, const float *cntl,
                        const ARint *icntl, ARint *info, float *rinfo);
 
 
@@ -88,19 +88,19 @@ extern "C"
 
   void F77NAME(umz21i)(ARint *keep, double *cntl, ARint *icntl);
 
-  void F77NAME(umz2fa)(const ARint *n, const ARint *ne, 
+  void F77NAME(umz2fa)(const ARint *n, const ARint *ne,
                        const ARint *job, const ARlogical *transa,
                        const ARint *lvalue, const ARint *lindex,
                        arcomplex<double> *value, ARint *index, ARint *keep,
                        const double *cntl, const ARint *icntl,
-                       ARint *info, double *rinfo); 
+                       ARint *info, double *rinfo);
 
   void F77NAME(umz2so)(const ARint *n, const ARint *job,
                        const ARlogical *transc, const ARint *lvalue,
                        const ARint *lindex, arcomplex<double> *value,
-                       ARint *index, const ARint *keep, 
-                       const arcomplex<double> *b, arcomplex<double> *x, 
-                       arcomplex<double> *w, const double *cntl, 
+                       ARint *index, const ARint *keep,
+                       const arcomplex<double> *b, arcomplex<double> *x,
+                       arcomplex<double> *w, const double *cntl,
                        const ARint *icntl, ARint *info, double *rinfo);
 
 #endif // ARCOMP_H
